<!-- 
제네릭
  - 일반적인, 포괄적인 이라는 뜻
  - 타입을 파라미터로 사용하는 방법 제공
  - 타입을 미리 고정하지 않고 사용하는 시점에 타입을 정의할 수 있어서 재사용성이 높음
  - 함수, 클래스, 인터페이스, 별칭 등에서 사용할 수 있음
  - 타입변수 = 타입파라미터 = 제네릭타입변수 = 제네릭타입파라미터

  제네릭 함수
    - 모든 타입에 두루두루 쓸 수 있는 범용적인 함수
    - 제네릭 함수 타입 변수 T는 타입을 담는 변수, 상황에 따라 다른 타입을 담을 수 있음
    - 타입변수와 함께 여러 타입의 값을 인수로 받아서 범용적으로 쓸 수 있는 함수
    - 타입 변수에 할당되는 타입은 함수를 호출할 때 인수에 따라서 결정됨

      function identity<T>(arg: T): T {
        return arg;
      }

      const result = identity<string>("hello");
      const result2 = identity<number>(42);

      => 타입 T를 받아 arg를 매개변수로 받고 동일한 타입 T 반환

  제네릭 인터페이스
    - 제네릭 함수와 달리 타입으로 정의할 때 타입으로 어떤 변수에 반드시 꺽쇄를 열고 타입 변수에 타입을 직접 할당해야 함

  제네릭 클래스
    - 제네릭 인터페이스나 제네릭 클래스와 제네릭 타입변수와 다르게 클래스의 생성자를 호출할 때 생성자에 인수로 전달하는 값을 기준으로 타입 변수에 타입을 추론
    - new List<number> 이런식으로 명시적으로 타입을 명시해주지 않아도 됨

  프로미스
    - 프로미스는 resolve나 reject를 호출해서 전달하는 비동기 작업의 결과값의 타입을 자동으로 추론할 수 있는 기능은 없음
    - 결과 값이 기본적으로는 unknown으로 추론
-->

<!-- 
타입 조작하기
  - 기본타입|별칭|인터페이스로 만든 원래 존재하던 타입들을 상황에 따라 각각 다른 타입으로 변환하는 기능
  - 제네릭, 인덱스드 엑세스 타입, keyof 연산자, Mapped(맵드) 타입, 템플릿 리터럴 타입...

  인덱스드 엑세스 타입
    - 객체, 배열, 튜플 타입에서 특정 프로퍼티 혹은 요소의 타입을 추출하는 타입
    - 인덱스를 이용해서 다른 타입 내에 특정 property의 타입을 추출하는 타입

  Keyof 연산자
    - 특정 객체 타입으로부터 프로퍼티 키들을 모두 스트링 리터럴 유니온 타입으로 추출하는 연산자

  Mapped(맵드) 타입
    - 기존의 객체 타입으로부터 새로운 객체 타입을 만드는 타입
    - 맵드 타입은 인터페이스에선 만들 수 없음
    - 무조건 타입 별칭으로만 사용해야 함
    - 특정 객체의 타입을 원하는 대로 변환할 수 있다. 하나의 객체 타입으로 다양한 상황에 대처 가능

  템플릿 리터럴 타입
    - 스트링 리터럴 타입을 기반으로 정해진 패턴의 문자열만 포함하는 타입
    - 문자열로 여러가지 상황을 표현해야 하는 경우에 적합
-->

