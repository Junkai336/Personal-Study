<!-- 
객체지향프로그래밍(OOP, Object-Oriented Programming)
  - 객체지향 프로그래밍에서는 모든 데이터를 객체(object)로 취급
  - 객체는 사물로 비유 가능, 객체의 상태(state)나 행동(behavior)을 구체화하는 형태의 프로그래밍

클래스
  - 객체를 정의하는 틀 또는 설계도같은 의미
  - 클래스를 가지고 여러 객체를 생성하여 사용
  - 클래스는 객체의 상태를 나타내는 필드나 객체의 행동을 나타내는 메소드로 구성
  - 필드 : 클래스에 포함된 변수
  - 메소드 : 어떠한 특정 작업을 수행하기 위한 명령문 집합
  - 생성자 : 생성된 객체의 필드를 초기화해주는 특별한 메소드

  클래스 선언
  - 클래스란 객체 지향 프로그래밍의 추상화(abstraction)라는 개념을 직접 구현한 것
  - 자바는 개발자 편의를 위해 많은 수의 클래스를 미리 정의하여 제공하고 있음
  - 클래스 선언법은 접근 제어자와 함께 class 키워드를 사용하면 됨
  - 접근제어자는 정보 은닉(data hiding)을 위한 키워드
  - public 멤버는 모든 객체에서 접근할 수 있지만, private 멤버는 해당 객체 내 멤버 변수나 메소드만 접근할 수 있음

  접근제어자 class 클래스이름
    접근제어자 필드1타입 필드1이름;
    접근제어자 필드2타입 필드2이름;
    ...
    접근제어자 메소드1의 원형
    접근제어자 메소드2의 원형
    ...


  class car {
    private String modelName;
    private int modelYear;

    Car(String modelName, int modelYear) {
      this.modelName = modelName;
      this.modelYear = modelYear;
    }

    public String getModel() {
      return this.modelYear + "년식" + this.modelName + " " + this.color;
    }
  }



인스턴스
  - 클래스를 사용하기 위해서 우선 해당 클래스 타입의 객체를 선언해야 함
  - 클래스로부터 객체를 선언하는 과정을 클래스의 인스턴스화
  - 이렇게 선언된 해당 클래스 타입의 객체 -> 인스턴스(instance)
  - 인스턴스 : 메모리에 할당된 객체
  - 선언
      - 클래스이름 객체참조변수이름;
      - 객체참조변수이름 = new 클래스이름();
      - 클래스이름 객체참조변수이름 = new 클래스이름();
      
        Car myCar;
        myCar = new Car();
        Car myCar = new Car();
          선언      인스턴스생성
      - new 키워드를 사용하여 인스턴스를 생성하고, 해당 인스턴스의 주소를 미리 선언한 참조 변수에 저장하여 사용함.

메소드
  - 메소드를 사용하면 중복되는 코드의 반복적인 프로그래밍을 피할 수 있게 되고 모듈화로 인해 전체적인 코드 가독성 좋아짐
  - 자바 클래스는 멤버(member)로 속성을 표현하는 필드(field)와 기능을 표현하는 메소드(method)를 가짐
  - 메소드 정의
    - 접근제어자 반환타입 메소드이름(매개변수목록) { ... }
      - 접근제어자 : 해당 메소드에 접근할 수 있는 범위 명시
      - 반환타입(return type) : 메소드가 모든 작업을 마치고 반환하는 데이터 타입 명시
      - 메소드이름 : 메소드를 호출하기 위한 이름 명시
      - 매개변수 목록(parameters) : 메소드 호출 시 전달되는 인수의 값을 저장할 변수들을 명시
      - 구현부 : 메소드의 고유 기능을 수행하는 명령문 집합
  - 메소드 호출
    - 객체참조변수이름.메소드이름([인수1, 인수2, ...]);

  - 자바는 하나의 클래스에 같은 이름의 메소드를 둘 이상 정의 불가
  - 메소드 오버로딩으로 같은 이름의 메소드 중복하여 정의 가능

  메소드 시그니처
    - 메소드 선언부에 명시되는 매개변수 리스트
    - 두 메소드가 매개변수의 개수와 타입, 순서까지 같다면 두 메소드의 시그니처는 같음
  
  메소드 오버로딩
    - 매개변수의 개수나 타입을 다르게 하여 같은 이름의 또 다른 메소드를 작성하는 것
    - 같은 이름의 메소드를 중복하여 정의하는 것
    - 서로 다른 시그니처를 가지는 여러 메소드를 같은 이름으로 정의하는 것
    - 메소드에 사용되는 이름 절약 가능
    - 다형성을 구현하는 방법 중 하나
    - println() : 전달받는 매개변수의 타입에 따라 다양한 원형 중 적절한 원형을 호출하게 됨

    메소드 오버로딩 조건
      - 메소드의 이름이 같아야 함
      - 메소드의 시그니처(매개변수 개수 또는 타입)이 달라야 함
      - 반환타입과는 관계가 없고 반환 타입만 다른 경우 성립 안됨
      - void display(int a);
      - void display(int a, int b);
      - void display(int a, double b);

  재귀 호출(recursive call)
    - 메소드 내부에서 해당 메소드가 또다시 호출되는 것
    - 자기 자신을 호출하므로 끝없이 반복
    - 재귀 호출을 중단할 수 있도록 조건이 변경될 명령문을 반드시 포함해야 함

    의사코드(pseudo code)
      - 특정 프로그래밍 언어의 문법에 맞춰 작성된 것이 아닌, 일반적인 언어로 알고리즘을 표현한 코드
      ex)
        시작
          1. n이 1이 아니면, n과 1부터 (n-1)까지의 합을 더한 값을 반환함
          2. n이 1이면 그냥 1을 반환함
        끝

        int recursiveSum(int n) {
          if(n == 1) {
            return 1;                     // n이 1이면 1반환
          }
          return n + recursiveSum(n-1);   // n이 1이 아니면 n과 1부터 n-1까지의 합을 더한 값 반환 (1부터 n까지의 합은 1부터 n-1까지의 합에 n을 더하면 됨)
        }

    - if문 존재하지 않을 시 프로그램 실행 직후 스택 오버플로우에 의해 종료됨
    - 스택 오버플로우(stack overflow) : 메모리 구조 중 스택(stack) 영역에서 해당 프로그램이 사용할 수 있는 메모리 공간 이상을 사용하려고 할 때 발생


필드
  - 클래스에 포함된 변수(variable)
  - 선언된 위치에 따라
    - 클래스 변수(static variable)
    - 인스턴스 변수(instance variable)
    - 지역 변수(local variable)



생성자
  - 객체의 생성과 동시에 인스턴스 변수를 원하는 값으로 초기화할 수 있는 메소드
  - 클래스를 가지고 객체를 생성하면, 해당 객체는 메모리에 즉시 생성됨
  - 이렇게 생성된 객체는 모든 인스턴스 변수가 아직 초기화되지는 않은 상태
  - 클래스 변수, 인스턴스 변수는 별도로 초기화하지 않으면 초기값으로 자동 초기화
  - 생성자 이름은 해당 클래스의 이름과 같아야 함

  - 인스턴스 변수 중 private 변수는 사용자나 프로그램이 직접 접근 불가.
  - 그래서 인스턴스 변수에 접근할 수 있는 초기화만을 위한 public 메소드 필요
  - 초기화만을 위한 메소드는 객체가 생성된 후부터 사용되기 전까지 반드시 인스턴스 변수 초기화를 위해 호출되어야 함

  생성자 특징
    - 반환값이 없지만, 반환 타입을 void형으로 선언하지 않음
    - 초기화를 위한 데이터를 인수로 전달받을 수 있음
    - 객체를 초기화하는 방법이 여러 개 존재할 경우 하나의 클래스가 여러 개의 생성자를 가질 수 있음
      (메소드 오버로딩 가능)

  생성자 선언
    - 클래스이름() { ... }
    - 클래스이름(인수1, 인수2, ...) {}

  생성자 호출
    - new 키워드를 사용하여 객체를 생성할 때 자동으로 생성자가 호출됨

    ex)
      class Car {
        private String modelName;
        private int modelYear;
        private int currentSpeed
      }

      Car(String modelName, int modelYear) {
        this.modelName = modelName;
        this.modelYear = modelYear;
        this.currentSpeed = 0;
      }

      public String getModel() {
        return this.modelYear + this.modelName + this.currentSpeed;
      }

      public class Main {
        public static void main(String[] args) {
          Car myCar = new Car("아반떼", 2016); // 생성자 호출
          sout(myCar.getModel()); // 생성자에 의해 초기화 되었는 지 확인함
        }
      }

  this
    - this 참조 변수는 인스턴스가 바로 자기 자신을 참조하는데 사용하는 변수
    - 해당 인스턴스의 주소를 가리키고 있음
    - 생성자의 매개변수 이름과 인스턴스 변수의 이름이 같을 경우 인스턴스 변수 앞에 this 키워드를 붙여 구분해야 함
    - 자바에서는 this 참조 변수를 사용하여 변수에 접근할 수 있음
    - this 참조 변수를 사용할 수 있는 영역은 인스턴스 메소드뿐이며, 클래스 메소드에서는 사용할 수 없음
    - 모든 인스턴스 메소드에는 this 참조 변수가 숨겨진 지역 변수로 존재하고 있음

  this() 메소드
    - 생성자 내부에서만 사용 가능
    - 같은 클래스 다른 생성자 호출할 때 사용
    - 메소드에 인수를 전달하면, 생성자 중 메소드 시그니처가 일치하는 다른 생성자를 찾아 호출
    - 메소드 시그니처 : 메소드의 이름과 메소드의 원형에 명시되는 매개변수 리스트
    ex)
          Car(String modelName, int modelYear, String color, int maxSpeed) {
            this.modelName = modelName;
            this.modelYear = modelYear;
            this.color = color;
            this.maxSpeed = maxSpeed;
            this.currentSpeed = 0;
          }

          Car() { this("소나타", 2012, "검정색", 160); }  <- 다른 생성자 호출

          Car test = new Car(); ↑

    - 내부적으로 다른 생성자를 호출하여 인스턴스 변수를 초기화할 수 있음
    - 한 생성자에서 다른 생성자를 호출할 때 반드시 해당 생성자의 첫 줄에서만 호출할 수 있음

-->