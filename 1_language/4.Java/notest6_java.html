<!-- 
상속(inheritance)
  - 기존의 클래스에 기능을 추가하거나 재정의하여 새로운 클래스를 정의하는 것
  - 캡슐화, 추상화와 더불어 객체 지향 프로그래밍을 구성하는 중요한 특징 중 하나
  - 기존에 정의되어 있는 클래스의 모든 필드와 메소드를 물려받아 새로운 클래스 생성 가능
  - 기존에 정의되어있는 클래스 : 부모 클래스, 상위 클래스, 기초 클래스 라고도 함
  - 새롭게 작성되는 클래스 : 자식 클래스, 하위 클래스, 파생 클래스 라고도 함

  - 장점
    - 기존에 작성된 클래스 재활용
    - 자식 클래스 설계 시 중복되는 멤버를 미리 부모 클래스에 작성해 놓으면, 자식 클래스에서 해당 멤버 작성 안해도 됨
    - 클래스 간 계층적 관계를 구성함으로써 다형성의 문법적 토대 마련

  - 자식 클래스
    - 부모 클래스의 모든 특성을 물려받아 새롭게 작성된 클래스
    - class 자식클래스이름 extend 부모클래스이름 { ... }
    - 부모 클래스가 자식 클래스에 포함되는 형태
    - 부모 클래스에 새로운 필드 추가시 자식 클래스에도 자동으로 해당 필드가 추가된 것처럼 동작
    - 자식 클래스에는 부모 클래스의 "필드와 메소드만 상속" , "생성자와 초기화 블록은 상속 X"  
    - 부모 클래스의 접근 제어가 private, default면 자식 클래스에서 상속받지만 접근할 수는 없음

    class Parent {
      private int a = 10;
      public int b = 20;
    }

    class Child extend Parent {
      public int c = 30;
      void display() {
        sout(a); x 오류
        sout(b); o
        sout(c); o
      }
    }

    public class inheritance {
      public static void main(String[] args) {
        Child ch = new Child();
        ch.display();
      }
    }

    - 자바에서 클래스는 단 한 개의 클래스만 상속받는 단일 상속만 가능



  Object 클래스
    - 모든 클래스의 부모 클래스가 되는 클래스
    - 자바의 모든 클래스는 자동으로 Object 클래스의 모든 필드와 메소드를 상속받음
    - 별도로 extend 키워드를 사용하여 Object 클래스의 상속을 명시하지 않아도 Object 클래스의 모든 멤버 자유롭게 사용할 수 있음 (toString(), clone() 메소드 바로 사용이 그 예)

  super
    - 부모 클래스로부터 상속받은 필드나 메소드를 자식 클래스에서 참조하는 데 사용하는 참조 변수
    - 인스턴스 변수의 이름과 지역 변수의 이름이 같을 경우 this 키워드를 사용하여 구분할 수 있었고 마찬가지로 부모 클래스의 멤버와 자식 클래스 멤버의 이름이 같을 경우 super 키워드로 구별 가능
    - super 참조 변수를 통해 부모 클래스 멤버에 접근 가능
    - super 참조 변수를 사용할 수 있는 대상은 인스턴스 메소드 뿐 (클래스 메소드 X)

    class Parent { int a = 10; }

    class Child extends Parent {
      void display() {
        sout(a);
        sout(this.a);
        sout(super.a);
      }
    }

    public class Inheritance {
      public static void main(String[] args) {
        Child ch = new Child();
        ch.display();
      }
    }

    결과: 10 10 10



    class Parent {
      int a = 10;
    }

    class Child extends Parent {
      int a = 20;

      void display() {
        sout(a);
        sout(this.a);
        sout(super.a);
      }
    }

    public class Inheritance {
      public static void main(String[] args) {
        Child ch = new Child();
        ch.display();
      }
    }

    결과 : 20 20 10



  super() 메소드
    - this() 메소드가 같은 클래스의 다른 생성자를 호출할 때 사용된다면, super() 메소드는 부모 클래스의 생성자를 호출할 때 사용
    - 자식 클래스의 인스턴스를 생성하면, 해당 인스턴스에는 자식 클래스의 고유 멤버뿐만 아니라 부모 클래스의 모든 멤버까지도 포함되어 있음
    - 부모 클래스의 멤버를 초기화하기 위해서는 자식 클래스의 생성자에서 부모 클래스의 생성자까지 호출해야 함
    
    - 이러한 부모 클래스의 생성자 호출은 모든 클래스의 부모 클래스인 Object 클래스의 생성자까지 계속 거슬러 올라가며 수행됨
    - 따라서 자바 컴파일러는 부모 클래스의 생성자를 명시적으로 호출하지 않는 모든 자식 클래스의 생성자 첫 줄에 자동으로 super(); 명령문을 추가하여 부모 클래스의 멤버를
      초기화할 수 있도록 함
    
      - 그러나 자바 컴파일러는 컴파일 시 클래스에 생성자가 하나도 정의되어 있지 않아야만, 자동으로 기본 생성자를 추가해줌
      => 부모 클래스에 매개변수를 가지는 생성자를 하나라도 선언했다면, 부모 클래스에는 기본 생성자가 자동으로 추가되지 않음

      class Parent {
        int a;
        Parent(int n) { a = n; }
      }
        => 기본 생성자 자동 추가 X

      ---------------------------------

      class Parent {
        int a;
        Parent(int n) { a = n; }
      }

      class Child extends Parent {
        int b;
        Child() {
          super();
          b = 20;
        }
      }
        => Parent 클래스를 상속받은 자식 클래스에서 super() 메소드를 사용하여 부모 클래스의 기본 생성자 호출 시 오류 발생
        => 부모 클래스인 Parent 클래스에는 기본 생성자가 추가되어 있지 않기 때문

        => 매개변수를 가지는 생성자를 선언해야 할 경우 기본 생성자까지 명시적으로 선언하는 것이 좋음

      class Parent {
        int a;
        Parent() { a = 10; }
        Parent(int n) { a = n; }
      }

      class Child extends Parent {
        int b;
        Child() {
          super();    <- 그냥 실행시 자동으로 삽입
          super(40);  <- 매개변수가 있는 생성자에 의해 초기화
          b = 20;
        }
      }



  메소드 오버라이딩
    - 오버로딩(overloading) : 서로 다른 시그니처를 갖는 여러 메소드를 하나의 이름으로 정의하는 것
                              새로운 메소드를 정의함

    - 오버라이딩(overriding) : 상속 관계에 있는 부모 클래스에서 이미 정의된 메소드를 자식 클래스에서 같은 시그니처를 갖는 메소드로 다시 정의하는 것
                                상속받은 부모 클래스의 메소드를 재정의하여 사용하는 것
                                기존 메소드를 재정의 함

    - 오버라이딩 조건
      - 메소드의 동작만을 재정의하는 것이므로 메소드 선언부는 기존 메소드와 완전히 같아야 함
      - 메소드의 반환 타입은 부모 클래스의 반환 타입으로 타입 변환할 수 있는 타입이라면 변경 가능   <- ?
      - 부모 클래스의 메소드보다 접근 제어자를 더 좁은 범위로 변경 불가
      - 부모 클래스의 메소드보다 더 큰 범위의 예외 선언 불가

-->

<!-- 
다형성

-->