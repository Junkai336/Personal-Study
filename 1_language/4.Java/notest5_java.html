<!-- 
패키지
  - 클래스와 인터페이스의 집합
  - 물리적으로 하나의 디렉터리를 의미
  - 하나의 패키지에 속한 클래스나 인터페이스 파일은 모두 해당 패키지 이름의 디렉터리에 포함되어 있음
  - 패키지는 다른 패키지를 포함할 수 있음
  - 디렉터리 계층 구조는 점(.)으로 구분됨
  - ex) java.lang.String : java.lang 패키지에 속한 클래스

  패키지 선언
    - package 패키지이름;
    - 패키지의 경로까지 포함한 풀네임 명시

  이름없는 패키지
    - 자바의 모든 클래스는 반드시 하나 이상의 패키지에 포함되어야 함
    - 자바 컴파일러는 소스 파일에 어떠한 패키지 선언도 포함되지 않으면 기본적으로 이름 없는 패키지에 포함해 컴파일
    - 패키지를 명시하지 않은 모든 클래스와 인터페이스는 모두 같은 패키지에 포함

  import 문
    - 다른 파일에서 사용하기 위해 클래스 이름 앞에 패키지의 경로까지 포함한 풀네임 명시해 사용해야 함
    - 클래스를 사용할 때마다 매번 긴 이름을 사용하는 것은 비효율적이므로 자바에서 import 키워드 제공
    - 자바 컴파일러에 코드에서 사용할 클래스의 패키지에 대한 정보를 미리 제공하는 역할
    - import문을 사용하면 다른 패키지에 속한 클래스를 패키지 이름을 제외한 클래스 이름만으로 사용할 수 있게 됨
    - import 패키지이름.클래스이름;       // 해당 패키지의 특정 클래스만 사용
    - import 패키지이름.*;                // 해당 패키지의 모든 클래스를 클래스 이름만으로 사용하고 싶을 때 사용
    - import문을 선언할 때 별표(*)를 사용하는 것이 해당 패키지에 포함된 다른 모든 하위 패키지의 클래스까지 포함해주진 않음
      - import java.*       <- 아래 하위 패키지들을 포함해주진 않음
      - import java.awt.*
      - import java.util.*

  접근 제어자

  제어자(modifier)
    - 클래스와 클래스 멤버 선언 시 사용하여 부가적인 의미를 부여하는 키워드

    접근제어자
      - 객체지향에서의 정보 은닉(data hiding) : 사용자가 굳이 알 필요가 없는 정보는 사용자로부터 숨겨야 한다. 사용자는 언제나 최소한의 정보만으로 프로그램을 손쉽게 사용할 수 있게 됨
      - 클래스 외부에서의 직접적인 접근을 허용하지 않는 멤버를 설정하여 정보 은닉을 구체화할 수 있음

      - private
        - 외부에 공개되지 않으며, 외부에서는 직접 접근 불가
        - 자바 프로그램은 private 멤버에 직접 접근할 수 없으며, 해당 객체의 public 메소드를 통해서만 접근 가능
        - public 인터페이스를 직접 구성하지 않고, 클래스 내부의 세부적인 동작을 구현하는 데 사용됨

      - public
        - 외부로 공개되며, 해당 객체를 사용하는 프로그램 어디에서나 직접 접근 가능
        - public 메소드를 통해서만 해당 객체의 private 멤버에 접근 가능
        - public 메소드는 private 멤버와 프로그램 사이의 인터페이스(interface) 역할을 수행

      - default
        - 클래스 및 클래스 멤버의 접근 제어의 기본값
        - default를 위한 접근 제어자는 따로 존재하지 않음
        - 접근 제어자가 따로 지정되지 않으면 자동적으로 default 접근 제어를 가지게 됨
        - 같은 클래스의 멤버와 같은 패키지에 속하는 멤버에서만 접근 가능

      - protected
        - 자바 클래스는 private 멤버로 정보를 은닉하고, public 멤버로 사용자나 프로그램과의 인터페이스 구축
        - 부모 클래스와 관련된 접근 제어자
        - 부모 클래스에 대해서는 public 멤버처럼 취급되며, 외부에서는 private 멤버처럼 취급됨
        - protected 멤버에 접근할 수 있는 영역
          - 이 멤버를 선언한 클래스의 멤버
          - 이 멤버를 선언한 클래스가 속한 패키지의 멤버
          - 이 멤버를 선언한 클래스를 상속받은 자식 클래스 멤버

    기타제어자

      - final 제어자
        - 변경할 수 없다 의미
        - 필드나 지역 변수에 사용하면 값을 변경할 수 없는 상수(constant)
        - 클래스에 사용하면 해당 클래스는 다른 클래스가 상속받을 수 없게 됨
        - 메소드에 사용하면 해당 메소드는 오버라이딩(overriding)을 통한 재정의를 할 수 없게 됨
        - final 제어자 사용 가능 대상 : 클래스, 메소드, 필드, 지역 변수

        final cass Car {            // 상속을 통해 서브 클래스를 생성할 수 없음
          final int a               // 상수화
          final void b() {          // 오버라이딩 통해 재정의 불가
            final double num = 10.1 // 상수화되어 값 변경 불가
          }
        }

        - 메소드 오버라이딩 : 상속받은 부모 클래스의 메소드를 재정의하여 사용하는 것

      - static 제어자
        - '공통적인' 의미
        - static 제어자를 변수에 사용하면 해당 변수를 클래스 변수로 만들어 주고 메소드에 사용하면 해당 메소드를 클래스 메소드로 만들어 줌.
        - static 제어자 사용 가능 대상 : 메소드, 필드, 초기화 블록
        - 객체 인스턴스가 아닌 클래스 레벨에서 접근할 수 있음 (객체 없이 접근한다.)
        - static 접근 제어자를 사용한다고 해서 다른 패키지의 클래스를 import 없이 사용할 수 있는 것은 아님! (패키지 단위는 못 넘는다.)
        
        - 프로그램 시작시 최초에 단 한번만 생성되고 초기화됨.
        - 인스턴스를 생성하지 않고도 바로 사용 가능
        - 해당 클래스의 모든 인스턴스가 공유함  <- ?

        class Car {
          static int a            // 클래스 필드(static 변수)
          static {                // static 초기화 블록 (보통 클래스 필드의 초기화 진행)
          
          }
          static void b() {       // 클래스 메소드(static 메소드)
            ...
          }
        }

      - abstract 제어자
        - '추상적인' 의미
        - 추상 메소드
        - 선언부만 있고 구현부가 없는 메소드
        - 반드시 abstract 제어자를 붙여야 함
        - 추상 메소드가 포함하고 있는 추상 클래스도 반드시 abstract 제어자를 붙여야 함
        - abstract 제어자 사용 대상 : 클래스, 메소드
        
        abstract class Car {     // 추상 클래스
          abstract void a();     // 추상 메소드
        }



  - final과 abstract 함께 사용 불가 : final 제어자는 상속불가, abstract 클래스는 다른 클래스가 상속해서 오버라이딩 해야만 사용할 수 있음
  - static과 abstract 함께 사용 불가 : abstract 제어자를 가지는 메소드는 구현부가 없고, static 제어자를 가지는 메소드는 인스턴스를 생성하지 않고도 바로 사용할 수 있어야 함
  - 메소드 private와 abstrct 함께 사용 불가 : abstract 제어자를 가지는 메소드는 다른 클래스가 상속하여 오버라이딩해야만 사용할 수 있는데 private 제어자를 가지는 메소드는 자식 클래스에서 접근 불가
  - 메소드 private와 final은 함께 사용할 필요가 없음 : 둘다 해당 메소드가 오버라이딩을 통한 재저의를 할 수 없다는 의미를 가지므로 둘 중 하나만 사용해도 ㄱㅊ

  
-->

<!-- 
필드의 구분
  class Car {
    static int a  // 클래스 변수
    int b         // 인스턴스 변수

    void aa() {}
      int c = 10; // 지역 변수
  } 
  - 클래스 변수와 인스턴스 변수는 초기화를 하지 않아도 변수의 타입에 맞게 자동으로 초기화
  - 지역변수는 사용하기 전에 초기화하지 않으면, 자바 컴파일러가 오류 발생시킴

  - 클래스 변수(static variable)
    - 클래스 영역에 위치한 변수 중 static 키워드를 가지는 변수
    - 인스턴스를 생성하지 않고도 바로 사용 가능
    - 공유 변수(shared variable)
    - 해당 클래스의 모든 인스턴스가 공유해야 하는 값을 유지하기 위해 사용

  - 인스턴스 변수(instance variable)
    - 클래스 영역에 위치한 변수 중 static 키워드를 가지지 않는 변수
    - 인스턴스마다 가져야 하는 고유한 값을 유지하기 위해 사용

  - 지역 변수(local variable)
    - 메소드, 생성자, 초기화 블록 내 위치한 변수

    변수                      생성 시기                             소멸 시기            저장 메모리        사용법

    클래스 변수         클래스가 메모리에 올라갈 때               프로그램 종료          메소드 영역        클래스이름.변수이름

    인스턴스 변수       인스턴스가 생성될 때                      인스턴스 소멸          힙 영역            인스턴스이름.변수이름

    지역 변수           블록 내에서 변수 선언문 실행될 때         블록 벗어남            스택 영역          변수이름
-->

<!-- 
메소드의 구분
  class Car {
    boolean ok;                     // 인스턴스 변수
    void a() {                      // 인스턴스 메소드
      ok = true;  
    }

    static void b(boolean ok) {     // 클래스 메소드
      return !ok;
    }
  }

  - 클래스 메소드(static method)
    - static 키워드를 가지는 메소드
    - 인스턴스를 생성하지 않고도 바로 사용 가능
    - 클래스 메소드는 메소드 내부에서 인스턴스 변수를 사용할 수 없음
    - 메소드 내부에서 인스턴스 변수나 인스턴스 메소드를 사용하지 않는 메소드를 클래스 메소드로 정의하는 것이 일반적
    - 인스턴스 변수를 사용하지 않고, 전달된 매개변수만으로 동작   <- 흠..

  - 인스턴스 메소드(instance method)
    - static 키워드를 가지지 않는 메소드

  class Method {
    int a = 10, b = 20;
    int add() { return a + b;}                        // 인스턴스 메소드

    static int add(int x, int y) { return x + y; }    // 클래스 메소드
  }

  public class aaa {
    public static void main(String[] args) {
      sout(Method.add(20, 30));       // 클래스 메소드 호출
      
      Method method = new Method();
      sout(method.add())              // 인스턴스 메소드 호출

    }
  }
-->

<!-- 
초기화 블록
  - 필드 초기화
    - 자바에서 필드는 초기화하지 않아도 변수 타입에 맞는 초기값으로 자동 초기화
    - 지역 변수와 마찬가지로 적절한 값으로 초기화 후 사용하는 것이 좋음
      - 명시적 초기화
        - 필드 선언 동시에 초기화
          - int var = 1;

      - 생성자를 이용한 초기화
        - 객체 생성과 동시에 필드 초기화
        - 인스턴스를 생성할 때까지 필드를 초기화할 수 없음

      - 초기화 블록을 이용한 초기화
        - 클래스 필드의 초기화만을 담당하는 중괄호{} 로 둘러싸인 블록
        - 생성자보다 먼저 호출, static 키워드 유무에 따라 인스턴스 초기화 블록, 클래스 초기화 블록으로 나뉨
        - 명령문 및 제어문 사용 가능하므로 복잡한 초기화를 해야 할 경우 유용하게 사용됨

        - 인스턴스 초기화 블록
          - 중괄호{} 만을 사용하여 정의 가능
          - 생성자와 마찬가지로 인스턴스가 생성될 때마다 실행됨
          - 생성자보다 먼저 실행
          - 생성자와 인스턴스 초기화 블록의 차이는 거의 없으므로 잘 사용되진 않음
          - 여러 개의 생성자가 있으면 모든 생성자에서 공통으로 수행되어야 할 코드를 인스턴스 초기화 블록에 포함하여 코드 중복 막을 수 있음

          class Car {
            private String a;
            private int b;

            {
              this.currentSpeed = 0;   // 인스턴스 초기화 블록
            }

            Car();

            Car(String a, int b) {
              this.a = a;
              this.b = b;
            }

            public int getSpeed() {
              return currentSpeed
            }
          }

          public class aaa {
            public static void main(String[] args) {
              Car myCar = new Car();                  // 인스턴스 생성
              sout(myCar.getSpeed());                 // 인스턴스 메소드 호출
            }
          }

        - 클래스 초기화 블록
          - 인스턴스 초기화 블록에 static 키워드를 추가하여 정의
          - 클래스가 처음으로 메모리에 로딩될 때 단 한 번만 실행됨
          - 생성자나 인스턴스 초기화 블록으로는 수행할 수 없는 클래스 변수의 초기화를 수행할 때 사용됨

          class InitBlock {
            static int classVar;        // 클래스 변수
            int instanceVar;            // 인스턴스 변수

            static {
              classVar = 100;           // 클래스 초기화 블록을 이용한 클래스 변수 초기화
            }
          }

          public class aaa {
              public static void main(String[] args) {
              System.out.println(InitBlock.classVar);     // 클래스 변수에 접근
            }
          }

  - 필드 초기화 순서
    - 같은 필드 여러번 초기화 가능

    - 클래스 변수 : 기본값 -> 명시적 초기화 -> 클래스 초기화 블록
    - 인스턴스 변수 : 기본값 -> 명시적 초기화 -> 인스턴스 초기화 블록 -> 생성자

    class InitBlock {
      static int classVar = 10;           // 클래스 변수 명시적 초기화        1빠
      
      int instanceVar = 10;               // 인스턴스 변수 명시적 초기화      1빠
      
      static { classVar = 20; }           // 클래스 초기화 블록 초기화        2빠 : 얘 적용됨
      
      { instanceVar = 20; }               // 인스턴스 초기화 블록 초기화      2빠
      
      InitBlock() { instanceVar = 30; }   // 생성자 초기화                    3빠 : 얘 적용됨 (여러번 초기화하면 제일 마지막으로 초기화한 값만 남음)
    }

    public class Aaa {
      public static void main(String[] args) {
        sout(InitBlock.classVar);

        InitBlock init = new InitBlock();
        sout(init.intstanceVar)
      }
    }



-->