<!-- 
패키지
  - 클래스와 인터페이스의 집합
  - 물리적으로 하나의 디렉터리를 의미
  - 하나의 패키지에 속한 클래스나 인터페이스 파일은 모두 해당 패키지 이름의 디렉터리에 포함되어 있음
  - 패키지는 다른 패키지를 포함할 수 있음
  - 디렉터리 계층 구조는 점(.)으로 구분됨
  - ex) java.lang.String : java.lang 패키지에 속한 클래스

  패키지 선언
    - package 패키지이름;
    - 패키지의 경로까지 포함한 풀네임 명시

  이름없는 패키지
    - 자바의 모든 클래스는 반드시 하나 이상의 패키지에 포함되어야 함
    - 자바 컴파일러는 소스 파일에 어떠한 패키지 선언도 포함되지 않으면 기본적으로 이름 없는 패키지에 포함해 컴파일
    - 패키지를 명시하지 않은 모든 클래스와 인터페이스는 모두 같은 패키지에 포함

  import 문
    - 다른 파일에서 사용하기 위해 클래스 이름 앞에 패키지의 경로까지 포함한 풀네임 명시해 사용해야 함
    - 클래스를 사용할 때마다 매번 긴 이름을 사용하는 것은 비효율적이므로 자바에서 import 키워드 제공
    - 자바 컴파일러에 코드에서 사용할 클래스의 패키지에 대한 정보를 미리 제공하는 역할
    - import문을 사용하면 다른 패키지에 속한 클래스를 패키지 이름을 제외한 클래스 이름만으로 사용할 수 있게 됨
    - import 패키지이름.클래스이름;       // 해당 패키지의 특정 클래스만 사용
    - import 패키지이름.*;                // 해당 패키지의 모든 클래스를 클래스 이름만으로 사용하고 싶을 때 사용
    - import문을 선언할 때 별표(*)를 사용하는 것이 해당 패키지에 포함된 다른 모든 하위 패키지의 클래스까지 포함해주진 않음
      - import java.*       <- 아래 하위 패키지들을 포함해주진 않음
      - import java.awt.*
      - import java.util.*

  접근 제어자

  제어자(modifier)
    - 클래스와 클래스 멤버 선언 시 사용하여 부가적인 의미를 부여하는 키워드

    접근제어자
      - 객체지향에서의 정보 은닉(data hiding) : 사용자가 굳이 알 필요가 없는 정보는 사용자로부터 숨겨야 한다. 사용자는 언제나 최소한의 정보만으로 프로그램을 손쉽게 사용할 수 있게 됨
      - 클래스 외부에서의 직접적인 접근을 허용하지 않는 멤버를 설정하여 정보 은닉을 구체화할 수 있음

      - private
        - 외부에 공개되지 않으며, 외부에서는 직접 접근 불가
        - 자바 프로그램은 private 멤버에 직접 접근할 수 없으며, 해당 객체의 public 메소드를 통해서만 접근 가능
        - public 인터페이스를 직접 구성하지 않고, 클래스 내부의 세부적인 동작을 구현하는 데 사용됨

      - public
        - 외부로 공개되며, 해당 객체를 사용하는 프로그램 어디에서나 직접 접근 가능
        - public 메소드를 통해서만 해당 객체의 private 멤버에 접근 가능
        - public 메소드는 private 멤버와 프로그램 사이의 인터페이스(interface) 역할을 수행

      - default
        - 클래스 및 클래스 멤버의 접근 제어의 기본값
        - default를 위한 접근 제어자는 따로 존재하지 않음
        - 접근 제어자가 따로 지정되지 않으면 자동적으로 default 접근 제어를 가지게 됨
        - 같은 클래스의 멤버와 같은 패키지에 속하는 멤버에서만 접근 가능

      - protected
        - 자바 클래스는 private 멤버로 정보를 은닉하고, public 멤버로 사용자나 프로그램과의 인터페이스 구축
        - 부모 클래스와 관련된 접근 제어자
        - 부모 클래스에 대해서는 public 멤버처럼 취급되며, 외부에서는 private 멤버처럼 취급됨
        - protected 멤버에 접근할 수 있는 영역
          - 이 멤버를 선언한 클래스의 멤버
          - 이 멤버를 선언한 클래스가 속한 패키지의 멤버
          - 이 멤버를 선언한 클래스를 상속받은 자식 클래스 멤버

    기타제어자

      - final 제어자
        - 변경할 수 없다 의미
        - 필드나 지역 변수에 사용하면 값을 변경할 수 없는 상수(constant)
        - 클래스에 사용하면 해당 클래스는 다른 클래스가 상속받을 수 없게 됨
        - 메소드에 사용하면 해당 메소드는 오버라이딩(overriding)을 통한 재정의를 할 수 없게 됨
        - final 제어자 사용 가능 대상 : 클래스, 메소드, 필드, 지역 변수

        final cass Car {            // 상속을 통해 서브 클래스를 생성할 수 없음
          final int a               // 상수화
          final void b() {          // 오버라이딩 통해 재정의 불가
            final double num = 10.1 // 상수화되어 값 변경 불가
          }
        }

        - 메소드 오버라이딩 : 상속받은 부모 클래스의 메소드를 재정의하여 사용하는 것

      - static 제어자
        - '공통적인' 의미
        - static 제어자를 변수에 사용하면 해당 변수를 클래스 변수로 만들어 주고 메소드에 사용하면 해당 메소드를 클래스 메소드로 만들어 줌.
        - static 제어자 사용 가능 대상 : 메소드, 필드, 초기화 블록
        - 객체 인스턴스가 아닌 클래스 레벨에서 접근할 수 있음 (객체 없이 접근한다.)
        - static 접근 제어자를 사용한다고 해서 다른 패키지의 클래스를 import 없이 사용할 수 있는 것은 아님! (패키지 단위는 못 넘는다.)
        
        - 프로그램 시작시 최초에 단 한번만 생성되고 초기화됨.
        - 인스턴스를 생성하지 않고도 바로 사용 가능
        - 해당 클래스의 모든 인스턴스가 공유함  <- ?

        class Car {
          static int a            // 클래스 필드(static 변수)
          static {                // static 초기화 블록 (보통 클래스 필드의 초기화 진행)
          
          }
          static void b() {       // 클래스 메소드(static 메소드)
            ...
          }
        }

      - abstract 제어자
        - '추상적인' 의미
        - 추상 메소드
        - 선언부만 있고 구현부가 없는 메소드
        - 반드시 abstract 제어자를 붙여야 함
        - 추상 메소드가 포함하고 있는 추상 클래스도 반드시 abstract 제어자를 붙여야 함
        - abstract 제어자 사용 대상 : 클래스, 메소드
        
        abstract class Car {     // 추상 클래스
          abstract void a();     // 추상 메소드
        }



  - final과 abstract 함께 사용 불가 : final 제어자는 상속불가, abstract 클래스는 다른 클래스가 상속해서 오버라이딩 해야만 사용할 수 있음
  - static과 abstract 함께 사용 불가 : abstract 제어자를 가지는 메소드는 구현부가 없고, static 제어자를 가지는 메소드는 인스턴스를 생성하지 않고도 바로 사용할 수 있어야 함
  - 메소드 private와 abstrct 함께 사용 불가 : abstract 제어자를 가지는 메소드는 다른 클래스가 상속하여 오버라이딩해야만 사용할 수 있는데 private 제어자를 가지는 메소드는 자식 클래스에서 접근 불가
  - 메소드 private와 final은 함께 사용할 필요가 없음 : 둘다 해당 메소드가 오버라이딩을 통한 재저의를 할 수 없다는 의미를 가지므로 둘 중 하나만 사용해도 ㄱㅊ

  
-->