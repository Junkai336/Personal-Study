<!-- 

변수
  - 데이터를 저장하기 위해 프로그램에 의해 할당받은 메모리 공간

변수 이름 생성 규칙
  - 영문자, 숫자, _, $ 로만 구성 가능
  - 숫자로 시작할 수 없음
  - 공백을 포함할 수 없음
  - 예약어 사용 불가

변수 종류
  - 기본형(primitive type) 변수
    - 실제 연산에 사용되는 변수
    - 정수형: byte, short, int, long
    - 실수형: float, double
    - 문자형: char
    - 논리형: boolean

  - 참조형(reference type) 변수

변수 선언
  - 선언만 하기
    - 먼저 변수를 선언하여 메모리 공간을 할당받고 나중에 초기화
    - 선언만 된 변수는 반드시 초기화한 후에 사용해야 함 (안그러면 자바 컴파일러 오류 발생시킴)
    - 자바에서는 프로그램 안정성을 위해 초기화하지 않은 변수는 사용할 수 없도록 하고 있음
    - 타입 변수이름;

  - 선언과 동시에 초기화
    - 선언하고자 하는 변수들의 타입이 같다면 동시에 선언도 가능
    - 타입 변수이름[, 변수이름]
    - 타입 변수이름 = 초기값[, 변수이름 = 초기값]
      - int num1, num2;
      - double num3 = 1.1, num4 = 1.2;
    - 이미 선언된 변수는 동시에 초기화할 수 없음
      - num1 = 1, num2 = 2 (x)

상수
  - 상수는 변수와 달리 프로그램이 실행되는 동안 메모리에 저장된 데이터를 변경할 수 없음
  - 선언과 동시에 반드시 초기화
  - final 타입 변수이름 = 초기값;
    - final int AGE = 29;
  - 자바에서 상수 이름은 일반적으로 모두 대문자를 사용하여 선언, 여러 단어로 이루어진 경우 언더스코어(_)를 사용하여 구분

리터럴
  - 그 자체로 값을 의미
  - int age = 30; 중 30이 리터럴
    - 정수형 리터럴 : 123, -456
    - 실수형 리터럴 : 3.14, -45.6
    - 논리형 리터럴 : true, false
    - 문자형 리터럴 : "자바", "홍길동"
    - null 리터럴 : null (아무런 값도 가지고 있지 않은 빈 값)

리터럴 타입 접미사
  - 3.14와 같은 실수형 리터럴을 그대로 사용하면 double 형으로 인식
  - 실수형 리터럴 뒤에 F, f를 추가하면 자바는 float형으로 인식
  - 리터럴 뒤에 추가되어 해당 리터럴의 타입을 명시해주는 접미사
    - l 또는 L : long형 1000L
    - f 또는 F : float형 1.234F
    - d 또는 D : double형 1.2345D

-->

<!-- 

기본 타입(primitive type)
  - 타입은 해당 데이터가 메모리에 어떻게 저장되고 프로그램에서 어떻게 처리되어야 하는지를 명시적으로 알려주는 역할
  
  정수형 타입
    - 부호를 가지고 있으며, 소수 부분이 없는 수
    - 정수형 데이터 타입 결정시 자신이 사용하고자 하는 데이터 최대 크기 고려해야 함
    - 해당 타입이 표현할 수 있는 범위를 벗어난 데이터를 저장하면 오버플로우가 발생
    - byte  [할당 메모리 크기: 1바이트] (데이터 표현 범위: -128 ~ 127)
    - short [할당 메모리 크기: 2바이트] (데이터 표현 범위: -32,768 ~ 32,767) 
    - int   [할당 메모리 크기: 4바이트] (데이터 표현 범위: -2,147,483,648 ~ 2,147,483,647)
    - long  [할당 메모리 크기: 8바이트] (데이터 표현 범위: -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807)

    오버플로우
      - 해당 타입이 표현할 수 있는 최대 범위보다 큰 수 저장할 때 발생 현상

    언더플로우
      - 해당 타입이 표현할 수 있는 최소 범위보다 작은 수를 저장할 때 발생 현상

    byte num1 = 127;
    byte num2 = -128;

    num1++; => -128
    num2--; => 127

  실수형 타입
    - 소수부나 지수부가 있는 수
    - 정수보다 훨씬 더 넓은 표현 범위 가짐
    - float   [지수 길이 : 8비트]   [가수 길이: 23비트]   [소수 부분 6자리까지 오차 없이 표현할 수 있음]  [할당 메모리 크기 : 4바이트] [데이터 표현 범위: (3.4 X 10^-38) ~ (3.4 X 10^38)]
              가장 높은 자릿수부터 6자리까지 정확하게 표현 가능
    - double  [지수 길이 : 11비트]  [가수 길이: 52비트]   [소수 부분 15자리까지 오차없이 표현할 수 있음]  [할당 메모리 크기 : 8바이트] [데이터 표현 범위: (1.7 X 10^-308) ~ (1.7 X 10^308)]
              가장 높은 자릿수부터 15자리까지 오차없이 표현 가능

    실수 표현 방식
      - 고정 소수점 방식
        - 실수는 정수부와 소수부로 나누어짐
        - 소수부를 자릿수를 미리 정하여, 고정된 자릿수의 소수를 표현
        - 정수부와 소수부의 자릿수가 크지 않으므로 표현할 수 있는 범위가 매우 적음

      - 부동 소수점 방식
        - 하나의 실수를 가수부와 지수부로 나누어 표현
        - 고정 소수점 방식은 제한된 자릿수로 표현할 수 있는 범위가 매우 적지만 부동 소수점 방식은 매우 큰 실수까지 표현 가능
        - ex) 1.가수부 x 2^지수부-127
        - 부동 소수점 방식에 의한 실수 표현은 항상 오차가 존재한다는 단점을 가지고 있음
        - 컴퓨터에서의 실수 표현 방법은 정확한 표현이 아닌 언제나 근사치를 표현할 뿐임

  문자형 타입
    - 작은 정수나 문자 하나를 표현할 수 있는 타입
    - char
      - 컴퓨터는 2진수밖에 인식하지 못하므로 문자도 숫자로 표현해야 인식 가능
      - 어떤 문자를 숫자에 대응시킬 것인지 약속 필요
      - C, C++은 아스키코드로 문자 표현 (128개 문자 표현 가능)
      - 자바는 유니코드를 사용하여 문자 표현, 각 나라 모든 언어 표현 가능 (65,536개 문자 표현 가능)
      - [할당 메모리크기 : 2바이트] [데이터 표현 범위 : 0 ~ 2^16]

  논리형 타입
    - boolean
      - 기본값 : false
      - [할당 메모리크기 : 1바이트] [데이터 표현 범위 : true 또는 false]

  타입 변환
    - 하나의 타입을 다른 타입으로 바꾸는 것
    - boolean 형을 제외한 나머지 기본 타입 간 타입 변환을 자유롭게 수행할 수 있음
    - 자바에서 다른 타입끼리 연산은 우선 피연산자들을 모두 같은 타입으로 만든 후 수행
    - 메모리에 할당받은 바이트의 크기가 상대적으로 작은 타입 -> 큰 타입으로의 타입 변환은 생략 가능
    - 바이트 크기가 큰 타입 -> 작은 타입 변환은 데이터 손실이 발생함. (자바 컴파일 오류 발생)

    타입 변환 종류
      - 묵시적 타입 변환 (자동 타입 변환, implicit conversion)
        - 대입 연산이나 산술 연산에서 컴파일러가 자동으로 수행해주는 타입 변환
        - 데이터 손실이 발생하지 않거나 최소화 되는 방향으로 묵시적 타입 변환 진행
        - 자바에선 데이터 손실이 발생하는 대입 연산은 허용되지 않음
        - ex) double a = 7.0f + 3.14;
        - byte형 -> short형 -> int형 -> long형 -> float형 -> double형
                    char형  ->

      - 명시적 타입 변환 (강제 타입 변환, explicit conversion)
        - 사용자가 타입 캐스트 연산자() 를 사용하여 강제적으로 수행하는 타입 변환
        - (변환할 타입) 변활할 데이터
        - ex) int num = 1; double result2 = (double) num / num <-얘는 자동타입변환
        - 자바에서 산술 연산을 수행하고 얻는 결과값의 타입은 언제나 피연산자의 타입과 일치해야 함 (int형 데이터끼리 산술 연산 결과값은 언제나 int형 데이터 결과로 나옴)

-->

<!-- 

연산자
  - 연산자 우선순위, 결합방향
    - 우선순위 1 (가장 먼저 실행) (같은 우선 순위를 가지는 연산자가 둘 이상 있을 경우 결합 순서에 따라 실행 순서 결정)
      - [] : 첨자 연산자
      - . : 멤버 연산자
    - 우선순위 2
      - ++ : 후위 증가 연산자
      - -- : 후위 감소 연산자
    - 우선순위 3
      - ! : 논리 NOT 연산자
      - ~ : 비트 NOT 연산자
      - + : 양의 부호 (단항 연산자)
      - - : 음의 부호 (단항 연산자)
      - ++ : 전위 증가 연산자
      - -- : 전위 감소 연산자
      - (타입) : 타입 캐스트 연산자
    - 우선순위 4
      - * : 곱셈 연산자
      - / : 나눗셈 연산자
      - % : 나머지 연산자
    - 우선순위 5
      - + : 덧셈 연산자 (이항 연산자)
      - - : 뺄셈 연산자 (이항 연산자)
    - 우선순위 6
      - << : 비트 왼쪽 시프트 연산자
      - >> : 부호 비트를 확장하면서 비트 오른쪽 시프트
      - >>> : 부호 비트까지 모두 비트 오른쪽 시프트
    - 우선순위 7
      - < : 관계연산자(미만)
      - <= : 관계연산자(이하)
      - > : 관계연산자(초과)
      - >= : 관계연산자(이상)
    - 우선순위 8
      - == : 관계 연산자(~와 같은)
      - != : 관계 연산자(~와 같지 않은)
    - 우선순위 9
      - & : 비트 AND 연산자
    - 우선순위 10
      - ^ : 비트 XOR 연산자
    - 우선순위 11
      - | : 비트 OR 연산자
    - 우선순위 12
      - && : 논리 AND 연산자
    - 우선순위 13
      - || : 논리 OR 연산자
    - 우선순위 14
      - ?: : 삼항 조건 연산자
    - 우선순위 15
      - = : 대입 연산자 및 복합 대입 연산자
        (=, +=, -=, *=, /=, %=, <<=, >>=, >>>=, &=, ^=, |=)

  - 산술 연산자
    - 피연산자들의 결합 방향은 왼쪽 -> 오른쪽
    - 항 : 해당 연산의 실행이 가능하기 위해 필요한 값이나 변수
    - 이항 연산자 : 해당 연산의 실행을 위해서 두 개의 값이나 변수가 필요한 연산자
    - + : 왼쪽 피연산자에 오른쪽 피연산자를 더함
    - - : 왼쪽 피연산자에서 오른쪽 피연산자를 뺌
    - * : 왼쪽 피연산자에 오른쪽 피연산자를 곱함
    - / : 왼쪽 피연산자를 오른쪽 피연산자로 나눔
    - % : 왼쪽 피연산자를 오른쪽 피연산자로 나눈 후, 나머지 반환

  - 대입 연산자 (왼쪽 피연산자: 왼피, 오른쪽 피연산자: 오피)
    - = : 왼피에 오피 대입
    - += : 왼피에 오피 더한 후 결과값 왼피에 대입
    - -= : 왼피에 오피 뺀 후 결과값 왼피에 대입
    - *= : 왼피에 오피 곱한 후 결과값 왼피에 대입
    - /= : 왼피에 오피 나눈 후 결과값 왼피에 대입
    - %= : 왼피를 오피로 나눈 후 나머지를 왼피에 대입

    - &= : 왼피를 오피와 비트 AND 연산한 후 결과값 왼피에 대입
    - |= : 왼피를 오피와 비트 OR 연산한 후 결과값 왼피에 대입
    - ^= : 왼피를 오피와 비트 XOR 연산한 후 결과값 왼피에 대입
    - <<= : 왼피를 오피만큼 왼쪽 시프트한 후 결과값 왼피에 대입
    - >>= : 왼피를 오피만큼 부호를 유지하며 오른쪽 시프트한 후 결과값 왼피에 대입
    - >>>= : 왼피를 오피만큼 부호에 상관없이 오른쪽 시프트한 후 결과값 왼피에 대입

  - 증감 연산자
    - 피연산자를 1씩 증가 혹은 감소시킬 때 사용
    - ++x : 먼저 피연산자의 값을 1 증가시킨 후 해당 연산 진행 
    - --x : 먼저 피연산자의 값을 1 감소시킨 후 해당 연산 진행
    - x++ : 먼저 해당 연산을 수행하고 나서, 피연산자 값을 1 증가시킴
    - x-- : 먼저 해당 연산을 수행하고 나서, 피연산자 값을 1 감소시킴

  - 비교 연산자
    - == : 왼피와 오피가 같으면 참 반환
    - != : 왼피와 오피가 다르면 참 반환
    - > : 왼피가 오피보다 크면 참 반환
    - >= : 왼피가 오피보다 크거나 같으면 참 반환
    - < : 왼피가 오피보다 작으면 참 반환
    - <= : 왼피가 오피보다 작거나 같으면 참 반환

  - 논리 연산자
    - 주어진 논리식을 판단 true, false 결정
    - && : 논리식이 모두 참이면 참 반환       (논리 AND 연산)
    - || : 논리식 중 하나라도 참이면 참 반환  (논리 OR 연산)
    - ! : 논리식의 결과가 거짓이면 참 반환    (논리 NOT 연산)

  - 비트 연산자
    - 논리 연산자와 비슷하지만, 비트(bit) 단위로 논리 연산할 때 사용하는 연산자
    - 비트
    - & : 대응되는 비트가 모두 1이면 1 반환                              (비트 AND 연산)            [11001 & 11110 => 11000]
    - | : 대응되는 비트 중에서 하나라도 1이면 1 반환                      (비트 OR 연산)             [00001 & 11111 => 11111]
    - ^ : 대응되는 비트가 서로 다르면 1 반환                             (비트 XOR 연산)            [10001 & 11111 => 01110]
    - ~ : 비트를 1이면 0으로 , 0이면 1로 반전 시킴                       (비트 NOT 연산, 1의 보수)   [00110         => 11001]
    - << : 명시된 수만큼 비트를 전부 왼쪽으로 이동 시킴                   (비트 왼쪽 시프트 연산)     [1 => 10] [한 비트씩 왼쪽 이동할 때마다 값 2배씩 증가]
    - >> : 부호를 유지하면서 지정한 수만큼 비트를 전부 오른쪽으로 이동시킴  (비트 오른쪽 시프트 연산)   [110 => 011] [한 비트씩 오른쪽 이동할 때마다 값 2배씩 감소] [부호변동 X]
    - >>> : 지정한 수만큼 비트를 전부 오른쪽으로 이동시키며 새로운 비트는 전부 0이 됨                 [부호 비트 포함 오른쪽 이동] [양수는 >>와 같고 음수는 부호 비트까지 이동]

    1의 보수 : 이진수에서 각 비트를 반전시킨 값 0은 1, 1은 0
    2의 보수 : 1의 보수에 1을 더한 값

    01010100 -> 1의보수 : 10101011 -> 2의 보수(+1) : 10101100
    00001111 -> 1의보수 : 11110000 -> 2의 보수(+1) : 11110001

  - 삼항 연산자
    - 자바에서 유일하게 피연산자 3개 가짐
    - 조건식 ? 반환값1 : 반환값2
              (true)    (false)
    
    int num1 = 5, num2 = 7
    int result;

    result = ( (num1 - num2) > 0 ) ? num1 : num2 (두 수 중 더 큰 수는 result)

  - instanceof 연산자
    - 참조 변수가 참조하고 있는 인스턴스의 실제 타입 반환
    - 해당 객체가 어떤 클래스나 인터페이스로부터 생성되었는지 판별해주는 역할
    - 인스턴스이름 instanceof 클래스or인터페이스이름
    - 왼쪽 피연산자인 인스턴스가 오른쪽 피연산자인 클래스나 인터페이스로부터 생성되었으면 true 

    class A {}
    class B extends A {}
    public static void main(String[] args) {
      A a = new A();
      B b = new B();

      sout(a instanceof A) => true
      sout(a instanceof B) => false
      sout(b instanceof A) => true
    }

-->

<!-- 
제어문
  - 원하는 결과를 얻기 위해 프로그램의 순차적인 흐름을 제어해야 할 때가 있음
  - 이때 사용하는 명령문
  - 제어문에 속하는 명령문들은 중괄호{}로 둘러싸여 있음 (중괄호 영역{} = 블록)

  조건문
    - 조건식의 결과에 따라 별도의 명령을 수행하도록 제어하는 명령문
      - if문 : 참이면 실행, 거짓이면 아무것도 안함
      - if / else문 : else문은 if문이 거짓이면 실행
      - if / else if / else문 : 조건이 위에서부터 순차적으로 평가됨(if, else if문 참이면 if문 실행)
      - 삼항연산자 : 조건식 ? 반환값1 : 반환값2

      - switch문
        - 컴파일러가 최적화를 쉽게 할 수 있어서 속도 빠른 편
        - 조건값으로 int형으로 승격할 수 있는 integer promotion 값만이 사용 될 수 있음    <- ?
        - switch문의 조건값으로 byte형, short형, char형, int형의 변수나 리터럴 사용 가능
        - Byte, Short, Character, Integer 클래스 객체도 사용 가능   <- 래퍼 클래스(Wrapper class): 기본 타입에 해당하는 데이터를 객체로 포장해주는 클래스

        switch (조건 값) {
          case 값1:
            명령문
            break;
          case 값2:
            명령문
            break;
          ...
          default
            명령문
            break;
        }

        - default : 조건값이 어떠한 case 절에도 해당하지 않을 때 실행. 필수x 필요할 떄만 선언 가능
        - 각 case절 및 default절은 반드시 break 키워드를 포함하고 있어야 함 (안 포함하면 switch문 못 빠져나가고 밑으로 주르륵 실행)

        switch (ch) {

    case 'a':

    case 'e':

    case 'i':

    case 'o':

    case 'u':

        System.out.println("해당 문자는 소문자 모음입니다.");

        break;
    }

    이렇게 한번에 검사도 가능

  반복문
    - while문
      - 조건식 결과가 참인 동안 반복적으로 실행
      - while (조건식) {조건식의 결과가 참인동안 반복적으로 실행하고자 하는 명령문}

    - do / while문
      - 먼저 루프를 실행한 후 조건식 검사
      - do {조건식의 결과가 참인동안 반복적으로 실행하고자 하는 명령문} while (조건식)

    - for문
      - for (초기식; 조건식; 증감식) {
        조건식의 결과가 참인동안 반복적으로 실행하고자 하는 명령문
      }
      - for문이 종료되면 for문의 초기식에서 사용된 변수는 자동으로 소멸

    - 향상된 for문
      - for(타입 변수이름 : 배열or컬렉션이름) {
        배열의 길이만큼 반복적으로 실행하고자 하는 명령문
      }
        ex)
          int[] arr = new int[]{1,2,3,4,5}
          for (int e : arr) {
            sout(e);
          }

  제어문
    - 일반적으로 조건식의 검사를 통해 루프로 진입하면, 다음 조건식을 검사하기 전까지 루프 안 모든 명령문 실행
    - 제어문은 루프의 흐름을 직접 제어할 수 있도록 도와줌

    - continue문
      - 루프 내에서 사용하여 해당 루프의 나머지 부분을 건너뛰고 바로 다음 조건식으로 넘어가게 함
      - 특정 조건에 대한 예외 처리를 하고자 할 때 자주 사용

    - break문
      - 루프 내에서 사용하여 해당 반복문을 완전히 종료시킨 뒤 반복문 바로 다음에 위치한 명령문 실행
      - 조건식의 판단 결과와 상관없이 '반복문을 완전히 빠져나가고 싶을 때 사용'

    - break with label
      - 일반적인 break 문은 단 하나의 반복문만 빠져나가게 함
      - 여러 반복문이 중첩된 상황에서 '한번에 모든 반복문 빠져나가거나 특정 반복문까지만 빠져나가고 싶을 때 사용'
      - 가장 바깥쪽 반복문이나 빠져나가고 싶은 특정 반복문에 이름 설정 후 break + 이름 명시
        ex)
          allLoop :
          for (int i = 0; i < 1; i++) {
            for (int j = 0; j < 1; j++) {
              break allLoop;
            }
          }

-->