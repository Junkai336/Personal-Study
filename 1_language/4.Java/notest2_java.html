<!-- 

변수
  - 데이터를 저장하기 위해 프로그램에 의해 할당받은 메모리 공간

변수 이름 생성 규칙
  - 영문자, 숫자, _, $ 로만 구성 가능
  - 숫자로 시작할 수 없음
  - 공백을 포함할 수 없음
  - 예약어 사용 불가

변수 종류
  - 기본형(primitive type) 변수
    - 실제 연산에 사용되는 변수
    - 정수형: byte, short, int, long
    - 실수형: float, double
    - 문자형: char
    - 논리형: boolean

  - 참조형(reference type) 변수

변수 선언
  - 선언만 하기
    - 먼저 변수를 선언하여 메모리 공간을 할당받고 나중에 초기화
    - 선언만 된 변수는 반드시 초기화한 후에 사용해야 함 (안그러면 자바 컴파일러 오류 발생시킴)
    - 자바에서는 프로그램 안정성을 위해 초기화하지 않은 변수는 사용할 수 없도록 하고 있음
    - 타입 변수이름;

  - 선언과 동시에 초기화
    - 선언하고자 하는 변수들의 타입이 같다면 동시에 선언도 가능
    - 타입 변수이름[, 변수이름]
    - 타입 변수이름 = 초기값[, 변수이름 = 초기값]
      - int num1, num2;
      - double num3 = 1.1, num4 = 1.2;
    - 이미 선언된 변수는 동시에 초기화할 수 없음
      - num1 = 1, num2 = 2 (x)

상수
  - 상수는 변수와 달리 프로그램이 실행되는 동안 메모리에 저장된 데이터를 변경할 수 없음
  - 선언과 동시에 반드시 초기화
  - final 타입 변수이름 = 초기값;
    - final int AGE = 29;
  - 자바에서 상수 이름은 일반적으로 모두 대문자를 사용하여 선언, 여러 단어로 이루어진 경우 언더스코어(_)를 사용하여 구분

리터럴
  - 그 자체로 값을 의미
  - int age = 30; 중 30이 리터럴
    - 정수형 리터럴 : 123, -456
    - 실수형 리터럴 : 3.14, -45.6
    - 논리형 리터럴 : true, false
    - 문자형 리터럴 : "자바", "홍길동"
    - null 리터럴 : null (아무런 값도 가지고 있지 않은 빈 값)

리터럴 타입 접미사
  - 3.14와 같은 실수형 리터럴을 그대로 사용하면 double 형으로 인식
  - 실수형 리터럴 뒤에 F, f를 추가하면 자바는 float형으로 인식
  - 리터럴 뒤에 추가되어 해당 리터럴의 타입을 명시해주는 접미사
    - l 또는 L : long형 1000L
    - f 또는 F : float형 1.234F
    - d 또는 D : double형 1.2345D

-->

<!-- 

기본 타입(primitive type)
  - 타입은 해당 데이터가 메모리에 어떻게 저장되고 프로그램에서 어떻게 처리되어야 하는지를 명시적으로 알려주는 역할
  
  정수형 타입
    - 부호를 가지고 있으며, 소수 부분이 없는 수
    - 정수형 데이터 타입 결정시 자신이 사용하고자 하는 데이터 최대 크기 고려해야 함
    - 해당 타입이 표현할 수 있는 범위를 벗어난 데이터를 저장하면 오버플로우가 발생
    - byte  [할당 메모리 크기: 1바이트] (데이터 표현 범위: -128 ~ 127)
    - short [할당 메모리 크기: 2바이트] (데이터 표현 범위: -32,768 ~ 32,767) 
    - int   [할당 메모리 크기: 4바이트] (데이터 표현 범위: -2,147,483,648 ~ 2,147,483,647)
    - long  [할당 메모리 크기: 8바이트] (데이터 표현 범위: -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807)

    오버플로우
      - 해당 타입이 표현할 수 있는 최대 범위보다 큰 수 저장할 때 발생 현상

    언더플로우
      - 해당 타입이 표현할 수 있는 최소 범위보다 작은 수를 저장할 때 발생 현상

    byte num1 = 127;
    byte num2 = -128;

    num1++; => -128
    num2--; => 127

  실수형 타입
    - 소수부나 지수부가 있는 수
    - 정수보다 훨씬 더 넓은 표현 범위 가짐
    - float   [지수 길이 : 8비트]   [가수 길이: 23비트]   [소수 부분 6자리까지 오차 없이 표현할 수 있음]  [할당 메모리 크기 : 4바이트] [데이터 표현 범위: (3.4 X 10^-38) ~ (3.4 X 10^38)]
              가장 높은 자릿수부터 6자리까지 정확하게 표현 가능
    - double  [지수 길이 : 11비트]  [가수 길이: 52비트]   [소수 부분 15자리까지 오차없이 표현할 수 있음]  [할당 메모리 크기 : 8바이트] [데이터 표현 범위: (1.7 X 10^-308) ~ (1.7 X 10^308)]
              가장 높은 자릿수부터 15자리까지 오차없이 표현 가능

    실수 표현 방식
      - 고정 소수점 방식
        - 실수는 정수부와 소수부로 나누어짐
        - 소수부를 자릿수를 미리 정하여, 고정된 자릿수의 소수를 표현
        - 정수부와 소수부의 자릿수가 크지 않으므로 표현할 수 있는 범위가 매우 적음

      - 부동 소수점 방식
        - 하나의 실수를 가수부와 지수부로 나누어 표현
        - 고정 소수점 방식은 제한된 자릿수로 표현할 수 있는 범위가 매우 적지만 부동 소수점 방식은 매우 큰 실수까지 표현 가능
        - ex) 1.가수부 x 2^지수부-127
        - 부동 소수점 방식에 의한 실수 표현은 항상 오차가 존재한다는 단점을 가지고 있음
        - 컴퓨터에서의 실수 표현 방법은 정확한 표현이 아닌 언제나 근사치를 표현할 뿐임

  문자형 타입
    - 작은 정수나 문자 하나를 표현할 수 있는 타입
    - char
      - 컴퓨터는 2진수밖에 인식하지 못하므로 문자도 숫자로 표현해야 인식 가능
      - 어떤 문자를 숫자에 대응시킬 것인지 약속 필요
      - C, C++은 아스키코드로 문자 표현 (128개 문자 표현 가능)
      - 자바는 유니코드를 사용하여 문자 표현, 각 나라 모든 언어 표현 가능 (65,536개 문자 표현 가능)
      - [할당 메모리크기 : 2바이트] [데이터 표현 범위 : 0 ~ 2^16]

  논리형 타입
    - boolean
      - 기본값 : false
      - [할당 메모리크기 : 1바이트] [데이터 표현 범위 : true 또는 false]

  타입 변환
    - 하나의 타입을 다른 타입으로 바꾸는 것
    - boolean 형을 제외한 나머지 기본 타입 간 타입 변환을 자유롭게 수행할 수 있음
    - 자바에서 다른 타입끼리 연산은 우선 피연산자들을 모두 같은 타입으로 만든 후 수행
    - 메모리에 할당받은 바이트의 크기가 상대적으로 작은 타입 -> 큰 타입으로의 타입 변환은 생략 가능
    - 바이트 크기가 큰 타입 -> 작은 타입 변환은 데이터 손실이 발생함. (자바 컴파일 오류 발생)

    타입 변환 종류
      - 묵시적 타입 변환 (자동 타입 변환, implicit conversion)
        - 대입 연산이나 산술 연산에서 컴파일러가 자동으로 수행해주는 타입 변환
        - 데이터 손실이 발생하지 않거나 최소화 되는 방향으로 묵시적 타입 변환 진행
        - 자바에선 데이터 손실이 발생하는 대입 연산은 허용되지 않음
        - ex) double a = 7.0f + 3.14;
        - byte형 -> short형 -> int형 -> long형 -> float형 -> double형
                    char형  ->

      - 명시적 타입 변환 (강제 타입 변환, explicit conversion)
        - 사용자가 타입 캐스트 연산자() 를 사용하여 강제적으로 수행하는 타입 변환
        - (변환할 타입) 변활할 데이터
        - ex) int num = 1; double result2 = (double) num / num <-얘는 자동타입변환
        - 자바에서 산술 연산을 수행하고 얻는 결과값의 타입은 언제나 피연산자의 타입과 일치해야 함 (int형 데이터끼리 산술 연산 결과값은 언제나 int형 데이터 결과로 나옴)

-->

<!-- 

연산자
  - 연산자 우선순위, 결합방향
    - 우선순위 1
      - [] : 첨자 연산자
      - . : 멤버 연산자
    - 우선순위 2
      - ++ : 후위 증가 연산자
      - -- : 후위 감소 연산자
    - 우선순위 3
      - ! : 논리 NOT 연산자
      - ~ : 비트 NOT 연산자
      - + : 양의 부호 (단항 연산자)
      - - : 음의 부호 (단항 연산자)
      - ++ : 전위 증가 연산자
      - -- : 전위 감소 연산자
      - (타입) : 타입 캐스트 연산자
    - 우선순위 4
      - * : 곱셈 연산자
      - / : 나눗셈 연산자
      - % : 나머지 연산자
    - 우선순위 5
      - + : 덧셈 연산자 (이항 연산자)
      - - : 뺄셈 연산자 (이항 연산자)
    - 우선순위 6
      - << : 비트 왼쪽 시프트 연산자
      - >> : 부호 비트를 확장하면서 비트 오른쪽 시프트
      - >>> : 부호 비트까지 모두 비트 오른쪽 시프트
    - 우선순위 7
      - < : 관계연산자(미만)
      - <= : 관계연산자(이하)
      - > : 관계연산자(초과)
      - >= : 관계연산자(이상)
    - 우선순위 8

  - 산술 연산자
    - 피연산자들의 결합 방향은 왼쪽 -> 오른쪽
    - 항 : 해당 연산의 실행이 가능하기 위해 필요한 값이나 변수
    - 이항 연산자 : 해당 연산의 실행을 위해서 두 개의 값이나 변수가 필요한 연산자
    - + : 왼쪽 피연산자에 오른쪽 피연산자를 더함
    - - : 왼쪽 피연산자에서 오른쪽 피연산자를 뺌
    - * : 왼쪽 피연산자에 오른쪽 피연산자를 곱함
    - / : 왼쪽 피연산자를 오른쪽 피연산자로 나눔
    - % : 왼쪽 피연산자를 오른쪽 피연산자로 나눈 후, 나머지 반환

  - 대입 연산자

  - 증감 연산자

  - 비교 연산자

  - 논리 연산자

  - 비트 연산자

  - 삼항 연산자

  - instanceOf 연산자

-->