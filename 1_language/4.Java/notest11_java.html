<!-- 
컬렉션 프레임워크(collection framework)
  - 다수의 데이터를 쉽고 효과적으로 처리할 수 있는 표준화된 방법을 제공하는 클래스 집합
  - 데이터를 저장하는 자료 구조와 데이터를 처리하는 알고리즘을 구조화하여 클래스로 구현해놓은 것
  - 컬렉션 프레임워크는 자바의 인터페이스를 사용하여 구현됨

컬렉션 프레임워크 주요 인터페이스
  - 데이터를 저장하는 자료 구조에 따라 주요 인터페이스 정의
  - List, Set, Map 인터페이스
  - List, Set 인터페이스는 Collection 인터페이스를 상속받음
  - Map 인터페이스는 구조상의 차이로 별도로 정의됨

주요 인터페이스 특징
  - List<E> : 순서가 있는 데이터 집합 , 데이터 중복 허용 , Vector, ArrayList, LinkedList, Stack, Queue

  - Set<E> : 순서가 없는 데이터 집합 , 데이터 중복 불가 , HashSet, TreeSet

  - Map<K, V> : 순서 없음 , 키 값 한 쌍으로 이루어지는 데이터 집합 , 키는 중복 불가 , 값은 중복 허용 , HashMap, TreeMap, Hashtable, Properties

  - <E> , <K, V> : 컬렉션 프레임워크를 구성하는 모든 클래스가 제네릭으로 표현되어 있음

컬렉션 클래스(collection class)
  - 컬렉션 프레임워크에 속하는 인터페이스를 구현한 클래스
  - 컬렉션 프레임워크의 모든 컬렉션 클래스는 List, Set, Map 인터페이스 중 하나의 인터페이스 구현하고 있음

    import java.util.*;

    public class Collection01 {
      public static void main(String[] args) {
        ArrayList<String> arrList = new ArrayList<String>();

        arrList.add("ㅋㅋㄹ");

        for(int i = 0; i < arrList.size(); i++) {
          sout(arrList.get(i));
        }
      }
    }

Collection 인터페이스
  - List와 Set 인터페이스의 많은 공통된 부분을 Collection 인터페이스에서 정의하고 그것을 상속받음
  - 컬렉션을 다루는데 가장 기본적인 동작들을 정의하고 메소드로 제공 중

  - boolean add(E e) : 해당 컬렉션에 전달된 요소 추가

  - void clear() : 해당 컬렉션의 모든 요소 제거

  - boolean contains(Object o) : 해당 컬렉션이 전달된 객체를 포함하고 있는지 확인

  - boolean equals(Object o) : 해당 컬렉션과 전달된 객체가 같은지 확인

  - boolean isEmpty() : 해당 컬렉션이 비어있는지 확인

  - Iterator<E> iterator() : 해당 컬렉션의 반복자 반환

  - boolean remove(Object o) : 해당 컬렉션에서 전달된 객체 제거

  - int size() : 해당 컬렉션 요소의 총 개수 반환

  - Object[] toArray() : 해당 컬렉션의 모든 요소를 Object 타입의 배열로 반환

  cf) Collection은 인터페이스, Collections는 클래스

-->

<!-- 
List 컬렉션 클래스
    - 요소의 저장 순서 유지
    - 같은 요소의 중복 저장 허용

    ArrayList<E> 클래스
      - 내부적으로 배열을 이용해 요소를 저장
      - 인덱스를 이용해 배열 요소에 빠르게 접근 가능
      - 배열은 크기를 변경할 수 없는 인스턴스이므로, 크기를 늘리기 위해 새로운 배열을 생성하고 기존의 요소들을 옮겨야하는 복잡한 과정을 거침
        => 자동으로 수행되지만, 요소의 추가 삭제 작업에 걸리는 시간이 매우 길어지는 단점이 생김

        ArrayList<Integer> arrList = new ArrayList<Integer>();

        arrList.add(10);
        arrList.remove(10);
        arrList.set(0, 20);

        for (int e : arrList) {
          sout(e)
        }

        Collections.sort(arrList);  // 요소 정렬

        Iterator<Integer> iter = arrList.iterator();  // iterator() 메소드와 get() 메소드로 요소 출력
        while (iter.hasNext()) {
          sout(iter.next());
        }

          
    LinkedList<E> 클래스
      - ArrayList 클래스가 배열을 이용하여 요소를 저장함으로써 발생하는 단점을 극복하기 위해 고안
      - 내부적으로 연결 리스트(linked list)를 이용하여 요소 저장
      - 배열은 저장된 요소가 순차적으로 저장되지만 연결 리스트는 저장된 요소가 비순차적으로 분포되며 요소들 사이를 링크로 연결하여 구성
      - 다음 요소를 가리키는 참조만 가지는 연결 리스트를 단일 연결 리스트라고 함
      - List 인터페이스를 구현하므로 ArrayList 클래스와 사용할 수 있는 메소드가 거의 같음 (ArrayList와의 차이는 내부적으로 요소를 저장하는 방법)

        단일 연결 리스트
          - 요소의 저장과 삭제 작업이 다음 요소를 가리키는 참조만 변경하면 되므로 아주 빠르게 처리될 수 있음
          - 현재 요소에서 이전 요소로 접근하기가 매우 어려움

        이중 연결 리스트
          - 이전 요소를 가리키는 참조도 가지고 좀 더 많이 사용됨
          - LinkedList 클래스는 이중 연결 리스트를 내부적으로 구현한 것

        LinkedList<String> lnkList = new LinkedList<String>();

        lnkList.add("ㅎㅇ")
        lnkList.remove(1);
        lnkList.set(2, "둘");
        
        for (String e : lnkList) {
          sout(e);
        }


    Vector<E> 클래스
      - JSK 1.0부터 사용해온 ArrayList 클래스와 같은 동작을 수행하는 클래스
      - 현재 Vector 클래스는 ArrayList 클래스와 마찬가지로 List 인터페이스를 상속받고 메소드가 거의 같음
      - 현재는 기존 코드와의 호환성을 위해서만 남아 있음.

    List 인터페이스 메소드
      - Collection 인터페이스 상속 받음

      - boolean add(E e) : 해당 리스트에 전달된 요소 추가

      - void add(int index, E e) : 해당 리스트의 특정 위치에 전달된 요소 추가

      - void clear() : 해당 리스트의 모든 요소 제거

      - boolean contains(Object o) : 해당 리스트가 전달된 객체를 포함하고 있는지 확인

      - boolean equals(Object o) : 해당 리스트와 전달된 객체가 같은지 확인

      - E get(int index) : 해당 리스트의 특정 위치에 존재하는 요소 반환

      - boolean isEmpty() : 해당 리스트가 비어있는지 확인

      - Iterator<E> iterator() : 해당 리스트의 반복자 반환

      - boolean remove(Object o) : 해당 리스트에서 전달된 객체 제거

      - boolean remove(int index) : 해당 리스트의 특정 위치에 존재하는 요소 제거

      - E set(int index, E e) : 해당 리스트의 특정 위치에 존재하는 요소를 전달받은 객체로 대체

      - int size() : 해당 리스트의 요소의 총 개수 반환

      - Object[] toArray() : 해당 리스트의 모든 요소를 Object 타입 배열로 반환

-->

<!-- 
Stack<E> 클래스
  - List 컬렉션 클래스의 Vector 클래스를 상속받아 전형적인 스택 메모리 구조의 클래스 제공
  - 스택 메모리 구조는 선형 메모리 공간에 데이터를 저장하면서 후입선출(LIFO)의 시멘틱을 따르는 자료 구조
  - 가장 나중에 저장된 데이터(push)가 가장 먼저 인출(pop)되는 구조

  - Stack<Integer> st = new Stack<Integer>();

  - 스택 메모리 구조를 표현하기 위해 Vector 클래스의 메소드를 5개만 상속받아 사용

    - boolean empty() : 해당 스택이 비어있으면 true, 비어있지않으면 false

    - E peek() : 해당 스택의 제일 상단에 있는, 마지막으로 저장된 요소를 반환

    - E pop() : 해당 스택의 제일 상단에 있는, 마지막으로 저장된 요소를 반환하고, 해당 요소를 스택에서 제거

    - E push(E item) : 해당 스택의 제일 상단에 전달된 요소를 삽입

    - int search(Object o) : 해당 스택에서 전달된 객체가 존재하는 위치의 인덱스 반환,
                            이때 인덱스는 제일 마지막으로 저장된 요소의 위치부터 0이 아닌 1부터 시작함
                            (맨 마지막 인덱스부터 0말고 1.. 2.. 3.. 이런 식 인듯)


  ArrayDeque 클래스
    - 더 복잡하고 빠른 스택 구현
    - Deque 인터페이스 구현
    - search() 메소드는 지원하지 않음
    - Deque<Integer> st = new ArrayDeque<Integer>();


    Stack<Integer> st = new Stack<Integer>();         // 스택 생성
    Deque<Integer> st2 = new ArrayDeque<Integer>();

    st.push(4);
    st.push(2);
    st.push(3);
    st.push(1);

    sout(st.peek());              // 1
    sout(st);                     // [4, 2, 3, 1]

    sout(st.pop());               // 1
    sout(st);                     // [4, 2, 3]

    sout(st.search(4));           // 3
    sout(st.search(3));           // 1



Queue<E> 인터페이스
  - 클래스로 구현된 스택과 달리 자바에서 큐 메모리 구조는 별도의 인터페이스 형태로 제공됨

  - Queue 인터페이스를 상속받는 하위 인터페이스
    - Deque<E>
    - BlockingDeque<E>
    - BlockingQueue<E>
    - TransferQueue<E>

  - Queue 인터페이스를 직간접적으로 구현한 클래스는 상당히 많음
  - Deque 인터페이스를 구현한 LinkedList 클래스가 큐 메모리 구조를 구현하는 데 가장 많이 사용됨

  - Queue 메모리 구조는 선형 메모리 공간에 데이터를 저장하면서 선입선출(FIFO)의 시멘틱을 따르는 자료 구조
  - 가장 먼저 저장된 데이터(push)가 가장 먼저 인출(pop)되는 구조

  - LinkedList<String> qu = new LinkedList<String>();

  - Queue 인터페이스는 큐 메모리 구조를 표현하기 위해 Collection 인터페이스 메소드만 상속받아 사용

    - boolean add(E e) : 해당 큐의 '맨 뒤'에 전달된 요소 삽입, 삽입 성공시 true, 큐에 여유공간이 없어 삽입에 실패하면 illegalStateException 발생

    - E element() : 해당 큐의 맨 앞에 있는, 제일 먼저 저장된 요소 반환

    - boolean offer(E e) : 해당 큐의 맨 뒤에 / 전달된 요소를 삽입

    - E peek() : 해당 큐의 맨 앞에 있는, 제일 먼저 저장된 요소 반환, 큐가 비어있으면 null 반환

    - E poll() : 해당 큐의 맨 앞에 있는, 제일 먼저 저장된 요소 반환 후 해당 요소를 큐에서 제거, 큐가 비어있으면 null 반환

    - E remove() : 해당 큐의 맨 앞에 있는, 제일 먼저 저장된 요소 제거


  ArrayDeque 클래스
    - 더 복잡하고 빠른 큐 구현
    - Deque<Integer> qu = new ArrayDeque<Integer>();

    LinkedList<String> qu = new LinkedList<String>();   // 큐 생성
    // Deque<String> qu = new ArrayDeque<String>(); 

    qu.add("넷")
    qu.add("둘")
    qu.add("셋")
    qu.add("하나")

    sout(qu.peek());  // 넷
    sout(qu);         // [넷, 둘, 셋, 하나]

    sout(qu.poll());  // 넷
    sout(qu);         // [둘, 셋, 하나]

    qu.remove("하나");
    sout(qu);         // [둘, 셋]

    cf) ArrayDeque 클래스는 스택과 큐 메모리 구조 모두 구현하는데 가장 적합한 클래스

-->

<!-- 
Deque<E>
  - Double-Ended Queue
  - 양쪽 끝에서 요소를 추가하거나 제거할 수 있음
  - 양방향 삽입 및 삭제 가능
  - 스택이나 큐로 사용할 수 있음
  - 예시 구현 클래스 : ArrayDeque, LinkedList

BlockingDeque<E>
  - Deque를 확장한 인터페이스
  - 스레드 간의 동기화 지원
  - 요소를 추가하거나 제거할 때, 큐가 비어있거나 가득 차 있을 경우 스레드를 블록시킬 수 있음
  - 멀티스레드 환경에서 안전하게 사용 가능
  - 주요 메소드 : offerFirst, offerLast, takeFirst, takeLast

BlockingQueue<E>
  - 스레드 간의 동기화를 지원하는 큐
  - 스레드가 큐에서 요소를 추가하거나 제거할 때, 큐의 상태에 따라 스레드를 블록시킬 수 있음
  - 주로 프로듀서-컨슈머 패턴에서 사용됨
  - 주요 구현 클래스 : ArrayBlockingQueue, LinkedBlockingQueue, PriorityBlockingQueue

TransferQueue<E>
  - BlockingQueue의 확장 인터페이스
  - 데이터를 소비할 준비가 된 스레드에만 데이터를 전송할 수 있음
  - transfer() 메소드를 통해 소비자가 대기 중일 때만 데이터 전달
  - 소비자가 대기중이지 않으면 transfer() 메소드는 소비자가 대기할 때까지 블록됨
  - 주요 구현 클래스 : LinkedTransferQueue

ArrayDeque
  - Deque 인터페이스를 구현한 클래스
  - 크기가 가변적인 배열로 구현된 덱
  - 빠른 요소 삽입 및 삭제 가능
  - 스레드에 안전하지 않음
  - 동기화가 필요하지 않은 상황에서 스택 또는 큐로 사용할 수 있음
  - LinkedList보다 메모리 효율성이 높고 성능이 뛰어남
-->

<!-- 
Set 컬렉션 클래스
  - 요소의 저장 순서를 유지하지 않음
  - 같은 요소의 중복 저장 불가

  HashSet<E> 클래스
    - 해시 알고리즘을 사용하여 검색 속도가 매우 빠름
    - 내부적으로 HashMap 인스턴스를 이용하여 요소 저장

    - 요소의 저장 순서를 바꿔도 저장되는 순서에는 영향을 미치지 않음
    - 이미 존재하는 요소를 추가하려고 하면, 해당 요소를 저장하지 않고 false 반환

      HashSet<String> hs = new HashSet<String>();

      hs.add("홍");
      hs.add("이");
      
      sout(hs.add("임"));
      sout(hs.add("임"));     // 저장 안됨

      for(String e : hs) {
        ...
      }

      Iterator<String> iter = hs.iterator();

      while(iter.hasNext()) {
        sout(iter.next());
      }

      sout(hs.size());

  TreeSet<E> 클래스
    - 데이터가 정렬된 상태로 저장되는 이진 검색 트리(binary search tree) 형태로 요소 저장
    - 이진 검색 트리는 데이터를 추가하거나 제거하는 등 기본 동작 시간이 매우 빠름
    - TreeSet 인스턴스에 저장되는 요소들은 모두 정렬된 상태로 저장됨

    - subSet() 메소드
      - public NavigableSet<E> subSet(E fromElement, E toElement)
        - 첫번째 매개변수로 전달된 값에 해당하는 요소부터 두번째 매개변수로 전달된 값에 해당하는 요소 바로 직전까지의 요소 반환

      - public NavigableSet<E> subSet(E fromElement, boolean frominclusive, E toElement, boolean toInclusive)
        - 두번째와 네번째 매개변수로 각각 첫번째 세번째 매개변수로 전달된 값에 해당하는 요소를 포함할 것인지 아닌지 명시 가능
        - 10(포함?미포함?) ~ 20(포함?미포함?) 이 얘기인듯?

  LinkedHashSet
    - 요소를 삽입한 순서를 유지 (순서를 유지하는 Set)
    - 이중 연결 리스트를 사용하여 요소의 순서를 기억함
    - 1, 2, 3 순서로 요소를 추가하면 반복(iteration)할 때도 이 순서가 유지됨
    - 중복 불가
    - HashSet과 마찬가지로 해시 기반으로 요소 관리
    - 요소의 순서를 유지하기 위해 이중 연결 리스트 구조를 사용하므로 HashSet에 비해 더 많은 메모리를 차지


  cf) Collection 인터페이스에서는 Iterator 인터페이스를 구현한 클래스의 인스턴스를 반환하는 iterator() 메소드를 정의하여 각 요소에 접근하도록 하고 있음.
-->

<!-- 
Map 컬렉션 클래스
  - Collection 인터페이스와 다른 저장 방식을 가짐
  - Map 인터페이스를 구현한 Map 컬렉션 클래스들은 키와 값을 하나의 쌍으로 저장하는 방식 사용 (key-value)
  - 키 : 값을 찾기 위한 이름

  - 요소의 저장 순서 유지하지 않음
  - 키는 중복 불가
  - 값은 중복 가능

  HashMap<K, V> 클래스
    - 해시 알고리즘을 사용하여 검색 속도가 매우 빠름

    HashMap<String, Integer> hm = new HashMap<String, Integer>();

    hm.put("십", 10);
    hm.put("일", 1);

    sout(hm.keySet());

    for(String key : hm.keySet()) {
        sout(String.format("키 : %s, 값 : %s", key, hm.get(key)));
    }

    hm.remove("십");

    Iterator<String> keys = hm.keySet().iterator();

    while(keys.hasNext()) {
      String key = keys.next();
      sout(String.format("키 : %s, 값 : %s", key, hm.get(key)));
    }

    hm.replace("십", 100);

    hm.size();

  HashTable<K, V>
    - HashMap 클래스와 같은 동작을 하는 클래스
    - 기존 코드와의 호환성을 위해서만 남아 있음

  TreeMap<K, V>
    - 키와 값을 한 쌍으로 하는 데이터를 이진 검색 트리 형태로 저장
    - 이진 검색 트리는 데이터를 추가하거나 제거하는 등 기본 동작 시간이 매우 빠름



    HashMap<K, V> 메소드

      - void clear() : 해당 맵의 모든 매핑을 제거

      - boolean containsKey(Object key) : 해당 맵이 전달된 키를 포함하고 있는지 확인

      - boolean containsValue(Object value) : 해당 맵이 전달된 값에 해당하는 하나 이상의 키를 포함하고 있는지 확인

      - V get(Object key) : 해당 맵에서 전달된 키에 대응하는 값을 반환, 해당 맵이 전달된 키를 포함한 매핑을 포함하고 있지 않으면 null 반환

      - boolean isEmpty() : 해당 맵이 비어있는지 확인

      - Set<K> keySet() : 해당 맵에 포함되어 있는 모든 키로 만들어진 Set 객체 반환

      - V put(K key, V value) : 해당 맵에 전달된 키에 대응하는 값으로 특정 값 매핑함

      - V remove(Object Key) : 해당 맵에서 전달된 키에 대응하는 매핑을 제거함

      - boolean remove(Object key, Object value) : 해당 맵에서 특정 값에 대응하는 특정 키의 매핑을 제거함

      - V replace(K key, V value) : 해당 맵에서 전달된 키에 대응하는 값을 특정 값으로 대체함

      - boolean replace(K key, V oldValue, V newValue) : 해당 맵에서 특정 값에 대응하는 전달된 키의 값을 새로운 값으로 대체함

      - int size() : 해당 맵의 매핑의 총 개수 반환



    TreeMap<K, V> 메소드

      - Map.Entry<K,V> ceilingEntry(K key) : 해당 맵에서 전달된 키와 같거나, 전달된 키보다 큰 키 중에서 가장 작은 키와 그에 대응하는 값의 엔트리 반환, 해당 키 없으면 null 반환

      - K ceilingKey(K key) : 해당 맵에서 전달된 키와 같거나, 전달된 키보다 '큰 키' 중에서 가장 작은 키 반환, 해당 키 없으면 null 반환


      - void clear() : 해당 맵의 모든 매핑 제거


      - boolean containsKey(Object key) : 해당 맵이 전달된 키 포함하고 있는지 확인

      - boolean containsValue(Object Value) : 해당 맵이 전달된 값에 해당하는 하나 이상의 키를 포함하고 있는지 확인


      - NavigableMap<K, V> descendingMap() : 해당 맵에 포함된 모든 매핑을 역순으로 반환


      - Set<Map.Entry<K, V>> entrySet() : 해당 맵에 포함된 모든 매핑을 Set 객체로 반환


      - Map.Entry<K, V> firstEntry() : 해당 맵에서 현재 가장 작은(첫 번째) 키와 그에 대응하는 값의 엔트리 반환

      - K firstKey() : 해당 맵에서 현재 가장 작은(첫 번째) 키 반환


      - Map.Entry<K, V> floorEntry(K key) : 해당 맵에서 전달된 키와 같거나, 전달된 키보다 '작은' 키 중에서 가장 큰 키와 그에 대응하는 값의 엔트리를 반환. 해당 키 없으면 null 반환

      - K floorKey(K key) : 해당 맵에서 전달된 키와 같거나, 전달된 키보다 작은 키 중에서 가장 큰 키 반환, 해당 키 없으면 null 반환


      - V get(Object key) : 해당 맵에서 전달된 키에 대응하는 값 반환, 매핑 없으면 null 반환


      - SortedMap<K, V> headMap(K toKey) : 해당 맵에서 전달된 키보다 작은 키로 구성된 부분만 반환


      - Map.Entry<K, V> higherEntry(K key) : 해당 맵에서 전달된 키보다 작은 키 중에서 가장 큰 키와 그에 대응하는 값의 엔트리 반환, 해당 키 없으면 null 반환

      - K higherKey(K key) : 해당 맵에서 전달된 키보다 작은 키 중에서 가장 큰 키 반환, 해당 키 없으면 null 반환

      - Map.Entry<K, V> lowerEntry(K key) : 해당 맵에서 전달된 키보다 큰 키 중에서 가장 작은 키와 그에 대응하는 값의 엔트리 반환, 해당 키 없으면 null 반환

      - K lowerKey(K key) : 해당 맵에서 전달된 키보다 큰 키 중에서 가장 작은 키 반환, 해당 키 없으면 null 반환


      - Set<K> keySet() : 해당 맵에 포함되어 있는 모든 키로 만들어진 Set 객체 반환


      - Map.Entry<K, V> lastEntry() : 해당 맵에서 현재 가장 큰(마지막) 키와 그에 대응하는 값의 엔트리 반환

      - K lastKey() : 해당 맵에서 현재 가장 큰(마지막) 키 반환


      - Map.Entry<K, V> pollFirstEntry() : 해당 맵에서 현재 가장 작은(첫 번째) 키와 그에 대응하는 값의 엔트리 반환 후 제거

      - Map.Entry<K, V> pollLastEntry() : 해당 맵에서 현재 가장 큰(마지막) 키와 그에 대응하는 값의 엔트리 반환 후 제거


      - V put(K key, V value) : 해당 맵에 전달된 키에 대응하는 값으로 특정 값 매핑


      - V remove(Object key) : 해당 맵에서 전달된 키에 대응하는 매핑 제거

      - boolean remove(K key, V value) : 해당 맵에서 특정 값에 대응하는 특정 키의 매핑 제거


      - V replace(K key, V value) : 해당 맵에서 전달된 키에 대응하는 값을 특정 값으로 대체

      - boolean replace(K key, V oldValue, V newValue) : 해당 맵에서 특정 값에 대응하는 전달된 키의 값을 새로운 값으로 대체

      
      - int size() : 해당 맵의 매핑 총 개수 반환


      - SortedMap<K, V> subMap(K fromKey, K toKey) : 해당 맵에서 fromKey부터 toKey까지로 구성된 부분만 반환 (fromKey는 포함, toKey는 미포함)

      - SortedMap<K, V> tailMap(K fromKey) : 해당 맵에서 fromKey와 같거나, fromKey보다 큰 키로 구성된 부분만 반환



      cf) Map.Entry 인터페이스는 Map 인터페이스의 내부 인터페이스. 맵에 저장되는 엔트리의 조작을 위한 메소드가 정의되어 있음
      cf) 자바 공식 문서에서 키와 값으로 구성되는 데이터를 매핑(mapping) 또는 엔트리(entry)라고 기술함
--> 

<!-- 
Iterator<E> 인터페이스
  - 자바의 컬렉션 프레임워크는 컬렉션에 저장된 요소를 읽어오는 방법을 Iterator 인터페이스로 표준화하고 있음
  - Collection 인터페이스에서는 Iterator 인터페이스를 구현한 클래스의 인스턴스를 반환하는 iterator() 메소드를 정의하여 각 요소에 접근하도록 하고 있음
  
    LinkedList<Integer> lnkList = new LinkedList<Integer>();

    lnkList.add(4);
    lnkList.add(2);
    lnkList.add(3);
    lnkList.add(1);

    Iterator<Integer> iter = lnkList.iterator();

    while(iter.hasNext()) {
      sout(iter.next());        // 4 2 3 1
    }

  메소드
    - boolean hasNext() : 해당 이터레이션이 다음 요소를 가지고 있으면 true, 없으면 false
    - E next() : 이터레이션의 다음 요소 반환
    - default void remove() : 해당 반복자로 반환되는 마지막 요소를 현재 컬렉션에서 제거

  cf) 자바에서는 Enhhanced for 문 사용 권장, but 요소의 선택적 제거나 대체 등을 수행하기 위한 경우 반복자(iterator) 사용해야 함



Enumeration<E> 인터페이스
  - iterator 인터페이스와 같은 동작 하는 인터페이스
  - 기존 코드와의 호환성을 위해서만 남아있음



ListIterator<E> 인터페이스
  - Iterator 인터페이스를 상속받아 여러 기능 추가한 인터페이스
  - Iterator 인터페이스는 컬렉션 요소에 접근할 때 한 방향으로만 이동 가능
  - ListIterator 인터페이스는 컬렉션 요소의 대체, 추가, 인덱스 검색 등을 위한 작업에서 양방향 이동 지원
  - List 인터페이스를 구현한 List 컬렉션 클래스에서만 사용 가능

  ...
  ListIterator<Integer> iter = lnkList.listIterator();

  while(iter.hasPrevious()) {
    sout(iter.previous());
  }

  메소드
    - void add(E e) : 해당 리스트에 전달된 요소 추가
    
    - boolean hasNext() : 이 리스트 반복자가 해당 리스트를 '순방향'으로 순회할 때 다음 요소를 가지고 있으면 true, 아니면 false
    - boolean hasPrevious() : 이 리스트 반복자가 해당 리스트를 '역방향'으로 순회할 때 다음 요소를 가지고 있으면 true, 아니면 false
    
    - E next() : 리스트의 다음 요소 반환, 커서의 위치를 순방향으로 이동 시킴
    - E previous() : 리스트의 이전 요소 반환, 커서의 위치를 역방향으로 이동 시킴
    
    - int nextIndex() : 다음 next() 메소드를 호출하면 반환될 요소의 인덱스를 반환함.
    - int previousIndex() : 다음 previous() 메소드를 호출하면 반한될 요소의 인덱스를 반환함.
    
    - void remove() : next()나 previous() 메소드에 의해 반환된 가장 마지막 요소를 리스트에서 제거
    
    - void set(E e) : next()나 previous() 메소드에 의해 반환된 가장 마지막 요소를 전달된 객체로 대체

-->

<!-- 
Comparable<T> 인터페이스
  - 객체를 정렬하는 데 사용되는 메소드인 compareTo() 메소드 정의
  - 자바에서 같은 타입의 인스턴스를 서로 비교해야 하는 클래스들은 모두 Comparable 인터페이스를 구현하고 있음
  - Boolean 제외 래퍼 클래스, String, Time, Date 와 같은 클래스의 인스턴스는 모두 정렬 가능
  - 기본 정렬 순서는 오름차순(작은값 -> 큰값)

  메소드 (객체 정렬)                                                <- 인터페이스니까 얘를 구체적으로 구현하는 것인듯
    - int compareTo(T o) : 해당 객체와 전달된 객체의 순서를 비교함
  
  class Car implements Comparable<Car> {
      private String modelName;
      private int modelYear;
      private String color;

      Car(String mn, int my, String c) {
        this.modelName = mn;
        this.modelYear = my;
        this.color = c;
      }

      public String getModel() {
        return this.modelYear + this.modelName + this.color;
      }

      public int compareTo(Car obj) {
        if (this.modelYear == obj.modelYear) {
          return 0;
        } else if(this.modelYear < obj.modelYear) {
          return -1;
        } else {
          return 1                                        <- 이거
        }
      }

      public class Comparable01 {
        public static void main(String[] args) {
          Car car01 = new Car("아반떼", 2016, "노란색");
          Car car02 = new Car("소나타", 2011, "검정색");

          sout(car01.compareTo(car02));
        }
      }

    }


Comparator<T> 인터페이스
  - Comparable 인터페이스와 같이 객체를 정렬하는 데 사용되는 인터페이스
  - Comparable 인터페이스를 구현한 클래스는 기본적으로 오름차순 정렬
  
  but
  
  - Comparator 인터페이스는 내림차순이나 아니면 다른 기준으로 정렬하고 싶을 때 사용할 수 있음
  - Comparator 인터페이스를 구현하면 오름차순 이외의 기준으로도 정렬할 수 있게 되는 것
  - Comparator 인터페이스를 구현한 클래스에서 compare() 메소드를 재정의하여 사용하게 됨

    import java.util.*;

    class DescendingOrder implements Comparator<Integer> {
      public int compare(Integer o1, Integer 02) {
        if(o1 instanceof Comparable && o2 instanceof Comparable) {
          Integer c1 = (Integer) o1;
          Integer c2 = (Integer) o2;

          return c2.compareTo(c1);
        }
          return -1;
      }
    }

    public class Comparable02 {
      public static void main(String[] args) {
        TreeSet<Integer> ts = new TreeSet<Integer>(new DescendingOrder());

        ts.add(30);
        ts.add(40);
        ts.add(20);
        ts.add(10);

        Iterator<Integer> iter = ts.iterator();

        while(iter.hasNext()) {
          sout(iter.next());            // 40 30 20 10
        }
      }
    }

    - 메소드
      - int compare(T o1, T o2) : 전달된 두 객체의 순서를 비교함

      - boolean equals(Object obj) : 해당 comparator와 전달된 객체가 같은지 확인

      - default Comparator<T> reversed() : 해당 comparator의 역순인 comparator를 반환
-->

<!-- 
Collections
  - 컬렉션 프레임워크에서 사용되는 여러 유틸리티 메소드를 제공하는 유틸리티 클래스
  - java.util 패키지에 포함
  - List, Set, Map 등의 컬렉션을 조작하는 데 사용되는 정적 메소드 제공

  메소드

    정렬 및 검색 

      - sort(List<T> list) : 지정된 리스트를 기본 정렬 순서로 정렬

      - sort(List<T> list, Comparator<? super T> c) : 지정된 비교자를 사용해 리스트를 정렬

      - binarySearch(List<? extends T> list, T key) : 정렬된 리스트에서 지정된 키의 인덱스를 이진 검색을 사용해 찾음

      - reverse(List<?> list) : 지정된 리스트의 모든 요소 순서를 역순으로 바꿈

    최대값, 최소값, 빈도

      - max(Collection<? extends T> coll) : 컬렉션에서 가장 큰 요소 반환

      - min(Collection<? extends T> coll) : 컬렉션에서 가장 작은 요소 반환
    
      - frequency(Collection<?> c, Object o) : 컬렉션에서 지정된 객체의 발생 빈도 반환

      - disjoint(Collection<?> c1, Collection<?> c2) : 두 컬렉션이 공통 요소를 가지고 있는지 여부 반환

    리스트 조작

      - shuffle(List<?> list) : 리스트의 요소를 무작위로 섞음

      - rotate(List<?> list, int distance) : 리스트의 요소를 지정된 거리만큼 회전

      - swap(List<?> list, int i, int j) : 리스트의 두 요소를 서로 교환

      - fill(List<? super T> list, T obj) : 리스트의 모든 요소를 지정된 객체로 채움

      - copy(List<? super T> dest, List<? extends T> src) : 원본 리스트의 모든 요소를 대상 리스트로 복사

    싱글톤 컬렉션

      - singleton(T o) : 지정된 요소를 포함하는 불변 싱글톤 세트 반환

      - singletonList(T o) : 지정된 요소를 포함하는 불변 싱글톤 리스트 반환

      - singletonMap(K key, V value) : 지정된 키와 값을 포함하는 불변의 싱글톤 맵 반환

    동기화된 컬렉션

      - synchronizedList(List<T> list) : 동기화된(쓰레드 안전한) 리스트 반환

      - synchronizedSet(Set<T> set)

      - synchronizedMap(Map<K, V> map)

    불변 컬렉션

      - unmodifiableList(List<? extends T> list) : 수정할 수 없는 리스트 반환

      - unmodifiableSet(Set<? extends T> set)

      - unmodifiableMap(Map<? extends T> map)

    ex)
      List<String> list = Arrays.asList("banana", "apple", "cherry");
      
      Collections.sort(list);
      
    ex)
      List<Integer> list = Arrays.asList(3, 5, 7, 2, 5, 3);

      int max = Collections.max(list);                          // 7
      int min = Collections.min(list);                          // 2
      int freq = Collections.frequency(list, 3)                 // 3의 빈도수 2

    ex)
      Collections.rotate(list, 2)                               // 리스트를 오른쪽으로 2칸 회전
      Collections.shuffle(list)                                 // 리스트 요소 무작위 섞기

      Set<String> singletonSet = Collections.singleton("onlyOne");
      List<String> singletonList = Collections.singletonList("onlyOne");

      List<String. syncList = Collections.synchronizedList(new ArrayList<>());
      
      synchronized(syncList) {
        syncList.add("threadSafe");
      }

      List<String> unmodifiableList = Collections.unmodifiableList(list);
-->