<!-- 
컬렉션 프레임워크(collection framework)
  - 다수의 데이터를 쉽고 효과적으로 처리할 수 있는 표준화된 방법을 제공하는 클래스 집합
  - 데이터를 저장하는 자료 구조와 데이터를 처리하는 알고리즘을 구조화하여 클래스로 구현해놓은 것
  - 컬렉션 프레임워크는 자바의 인터페이스를 사용하여 구현됨

컬렉션 프레임워크 주요 인터페이스
  - 데이터를 저장하는 자료 구조에 따라 주요 인터페이스 정의
  - List, Set, Map 인터페이스
  - List, Set 인터페이스는 Collection 인터페이스를 상속받음
  - Map 인터페이스는 구조상의 차이로 별도로 정의됨

주요 인터페이스 특징
  - List<E> : 순서가 있는 데이터 집합 , 데이터 중복 허용 , Vector, ArrayList, LinkedList, Stack, Queue

  - Set<E> : 순서가 없는 데이터 집합 , 데이터 중복 불가 , HashSet, TreeSet

  - Map<K, V> : 순서 없음 , 키 값 한 쌍으로 이루어지는 데이터 집합 , 키는 중복 불가 , 값은 중복 허용 , HashMap, TreeMap, Hashtable, Properties

  - <E> , <K, V> : 컬렉션 프레임워크를 구성하는 모든 클래스가 제네릭으로 표현되어 있음

컬렉션 클래스(collection class)
  - 컬렉션 프레임워크에 속하는 인터페이스를 구현한 클래스
  - 컬렉션 프레임워크의 모든 컬렉션 클래스는 List, Set, Map 인터페이스 중 하나의 인터페이스 구현하고 있음

    import java.util.*;

    public class Collection01 {
      public static void main(String[] args) {
        ArrayList<String> arrList = new ArrayList<String>();

        arrList.add("ㅋㅋㄹ");

        for(int i = 0; i < arrList.size(); i++) {
          sout(arrList.get(i));
        }
      }
    }

Collection 인터페이스
  - List와 Set 인터페이스의 많은 공통된 부분을 Collection 인터페이스에서 정의하고 그것을 상속받음
  - 컬렉션을 다루는데 가장 기본적인 동작들을 정의하고 메소드로 제공 중

  - boolean add(E e) : 해당 컬렉션에 전달된 요소 추가

  - void clear() : 해당 컬렉션의 모든 요소 제거

  - boolean contains(Object o) : 해당 컬렉션이 전달된 객체를 포함하고 있는지 확인

  - boolean equals(Object o) : 해당 컬렉션과 전달된 객체가 같은지 확인

  - boolean isEmpty() : 해당 컬렉션이 비어있는지 확인

  - Iterator<E> iterator() : 해당 컬렉션의 반복자 반환

  - boolean remove(Object o) : 해당 컬렉션에서 전달된 객체 제거

  - int size() : 해당 컬렉션 요소의 총 개수 반환

  - Object[] toArray() : 해당 컬렉션의 모든 요소를 Object 타입의 배열로 반환

  cf) Collection은 인터페이스, Collections는 클래스

-->

<!-- 
List 컬렉션 클래스
    - 요소의 저장 순서 유지
    - 같은 요소의 중복 저장 허용

    ArrayList<E> 클래스
      - 내부적으로 배열을 이용해 요소를 저장
      - 인덱스를 이용해 배열 요소에 빠르게 접근 가능
      - 배열은 크기를 변경할 수 없는 인스턴스이므로, 크기를 늘리기 위해 새로운 배열을 생성하고 기존의 요소들을 옮겨야하는 복잡한 과정을 거침
        => 자동으로 수행되지만, 요소의 추가 삭제 작업에 걸리는 시간이 매우 길어지는 단점이 생김

        ArrayList<Integer> arrList = new ArrayList<Integer>();

        arrList.add(10);
        arrList.remove(10);
        arrList.set(0, 20);

        for (int e : arrList) {
          sout(e)
        }

        Collections.sort(arrList);  // 요소 정렬

        Iterator<Integer> iter = arrList.iterator();  // iterator() 메소드와 get() 메소드로 요소 출력
        while (iter.hasNext()) {
          sout(iter.next());
        }

          
    LinkedList<E> 클래스
      - ArrayList 클래스가 배열을 이용하여 요소를 저장함으로써 발생하는 단점을 극복하기 위해 고안
      - 내부적으로 연결 리스트(linked list)를 이용하여 요소 저장
      - 배열은 저장된 요소가 순차적으로 저장되지만 연결 리스트는 저장된 요소가 비순차적으로 분포되며 요소들 사이를 링크로 연결하여 구성
      - 다음 요소를 가리키는 참조만 가지는 연결 리스트를 단일 연결 리스트라고 함
      - List 인터페이스를 구현하므로 ArrayList 클래스와 사용할 수 있는 메소드가 거의 같음 (ArrayList와의 차이는 내부적으로 요소를 저장하는 방법)

        단일 연결 리스트
          - 요소의 저장과 삭제 작업이 다음 요소를 가리키는 참조만 변경하면 되므로 아주 빠르게 처리될 수 있음
          - 현재 요소에서 이전 요소로 접근하기가 매우 어려움

        이중 연결 리스트
          - 이전 요소를 가리키는 참조도 가지고 좀 더 많이 사용됨
          - LinkedList 클래스는 이중 연결 리스트를 내부적으로 구현한 것

        LinkedList<String> lnkList = new LinkedList<String>();

        lnkList.add("ㅎㅇ")
        lnkList.remove(1);
        lnkList.set(2, "둘");
        
        for (String e : lnkList) {
          sout(e);
        }


    Vector<E> 클래스
      - JSK 1.0부터 사용해온 ArrayList 클래스와 같은 동작을 수행하는 클래스
      - 현재 Vector 클래스는 ArrayList 클래스와 마찬가지로 List 인터페이스를 상속받고 메소드가 거의 같음
      - 현재는 기존 코드와의 호환성을 위해서만 남아 있음.

    List 인터페이스 메소드
      - Collection 인터페이스 상속 받음

      - boolean add(E e) : 해당 리스트에 전달된 요소 추가

      - void add(int index, E e) : 해당 리스트의 특정 위치에 전달된 요소 추가

      - void clear() : 해당 리스트의 모든 요소 제거

      - boolean contains(Object o) : 해당 리스트가 전달된 객체를 포함하고 있는지 확인

      - boolean equals(Object o) : 해당 리스트와 전달된 객체가 같은지 확인

      - E get(int index) : 해당 리스트의 특정 위치에 존재하는 요소 반환

      - boolean isEmpty() : 해당 리스트가 비어있는지 확인

      - Iterator<E> iterator() : 해당 리스트의 반복자 반환

      - boolean remove(Object o) : 해당 리스트에서 전달된 객체 제거

      - boolean remove(int index) : 해당 리스트의 특정 위치에 존재하는 요소 제거

      - E set(int index, E e) : 해당 리스트의 특정 위치에 존재하는 요소를 전달받은 객체로 대체

      - int size() : 해당 리스트의 요소의 총 개수 반환

      - Object[] toArray() : 해당 리스트의 모든 요소를 Object 타입 배열로 반환

-->

<!-- 
Stack<E> 클래스
  - List 컬렉션 클래스의 Vector 클래스를 상속받아 전형적인 스택 메모리 구조의 클래스 제공
  - 스택 메모리 구조는 선형 메모리 공간에 데이터를 저장하면서 후입선출(LIFO)의 시멘틱을 따르는 자료 구조
  - 가장 나중에 저장된 데이터(push)가 가장 먼저 인출(pop)되는 구조

  - Stack<Integer> st = new Stack<Integer>();

  - 스택 메모리 구조를 표현하기 위해 Vector 클래스의 메소드를 5개만 상속받아 사용

    - boolean empty() : 해당 스택이 비어있으면 true, 비어있지않으면 false

    - E peek() : 해당 스택의 제일 상단에 있는, 마지막으로 저장된 요소를 반환

    - E pop() : 해당 스택의 제일 상단에 있는, 마지막으로 저장된 요소를 반환하고, 해당 요소를 스택에서 제거

    - E push(E item) : 해당 스택의 제일 상단에 전달된 요소를 삽입

    - int search(Object o) : 해당 스택에서 전달된 객체가 존재하는 위치의 인덱스 반환,
                            이때 인덱스는 제일 마지막으로 저장된 요소의 위치부터 0이 아닌 1부터 시작함
                            (맨 마지막 인덱스부터 0말고 1.. 2.. 3.. 이런 식 인듯)


  ArrayDeque 클래스
    - 더 복잡하고 빠른 스택 구현
    - Deque 인터페이스 구현
    - search() 메소드는 지원하지 않음
    - Deque<Integer> st = new ArrayDeque<Integer>();


    Stack<Integer> st = new Stack<Integer>();         // 스택 생성
    Deque<Integer> st2 = new ArrayDeque<Integer>();

    st.push(4);
    st.push(2);
    st.push(3);
    st.push(1);

    sout(st.peek());              // 1
    sout(st);                     // [4, 2, 3, 1]

    sout(st.pop());               // 1
    sout(st);                     // [4, 2, 3]

    sout(st.search(4));           // 3
    sout(st.search(3));           // 1



Queue<E> 인터페이스
  - 클래스로 구현된 스택과 달리 자바에서 큐 메모리 구조는 별도의 인터페이스 형태로 제공됨

  - Queue 인터페이스를 상속받는 하위 인터페이스
    - Deque<E>
    - BlockingDeque<E>
    - BlockingQueue<E>
    - TransferQueue<E>

  - Queue 인터페이스를 직간접적으로 구현한 클래스는 상당히 많음
  - Deque 인터페이스를 구현한 LinkedList 클래스가 큐 메모리 구조를 구현하는 데 가장 많이 사용됨

  - Queue 메모리 구조는 선형 메모리 공간에 데이터를 저장하면서 선입선출(FIFO)의 시멘틱을 따르는 자료 구조
  - 가장 먼저 저장된 데이터(push)가 가장 먼저 인출(pop)되는 구조

  - LinkedList<String> qu = new LinkedList<String>();

  - Queue 인터페이스는 큐 메모리 구조를 표현하기 위해 Collection 인터페이스 메소드만 상속받아 사용

    - boolean add(E e) : 해당 큐의 '맨 뒤'에 전달된 요소 삽입, 삽입 성공시 true, 큐에 여유공간이 없어 삽입에 실패하면 illegalStateException 발생

    - E element() : 해당 큐의 맨 앞에 있는, 제일 먼저 저장된 요소 반환

    - boolean offer(E e) : 해당 큐의 맨 뒤에 / 전달된 요소를 삽입

    - E peek() : 해당 큐의 맨 앞에 있는, 제일 먼저 저장된 요소 반환, 큐가 비어있으면 null 반환

    - E poll() : 해당 큐의 맨 앞에 있는, 제일 먼저 저장된 요소 반환 후 해당 요소를 큐에서 제거, 큐가 비어있으면 null 반환

    - E remove() : 해당 큐의 맨 앞에 있는, 제일 먼저 저장된 요소 제거


  ArrayDeque 클래스
    - 더 복잡하고 빠른 큐 구현
    - Deque<Integer> qu = new ArrayDeque<Integer>();

    LinkedList<String> qu = new LinkedList<String>();   // 큐 생성
    // Deque<String> qu = new ArrayDeque<String>(); 

    qu.add("넷")
    qu.add("둘")
    qu.add("셋")
    qu.add("하나")

    sout(qu.peek());  // 넷
    sout(qu);         // [넷, 둘, 셋, 하나]

    sout(qu.poll());  // 넷
    sout(qu);         // [둘, 셋, 하나]

    qu.remove("하나");
    sout(qu);         // [둘, 셋]

    cf) ArrayDeque 클래스는 스택과 큐 메모리 구조 모두 구현하는데 가장 적합한 클래스

-->

<!-- 

Deque<E>
  -

BlockingDeque<E>
  -

BlockingQueue<E>
  -

TransferQueue<E>
  -

ArrayDeque
  - 

-->