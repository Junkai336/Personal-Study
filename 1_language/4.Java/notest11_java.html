<!-- 
컬렉션 프레임워크(collection framework)
  - 다수의 데이터를 쉽고 효과적으로 처리할 수 있는 표준화된 방법을 제공하는 클래스 집합
  - 데이터를 저장하는 자료 구조와 데이터를 처리하는 알고리즘을 구조화하여 클래스로 구현해놓은 것
  - 컬렉션 프레임워크는 자바의 인터페이스를 사용하여 구현됨

컬렉션 프레임워크 주요 인터페이스
  - 데이터를 저장하는 자료 구조에 따라 주요 인터페이스 정의
  - List, Set, Map 인터페이스
  - List, Set 인터페이스는 Collection 인터페이스를 상속받음
  - Map 인터페이스는 구조상의 차이로 별도로 정의됨

주요 인터페이스 특징
  - List<E> : 순서가 있는 데이터 집합 , 데이터 중복 허용 , Vector, ArrayList, LinkedList, Stack, Queue

  - Set<E> : 순서가 없는 데이터 집합 , 데이터 중복 불가 , HashSet, TreeSet

  - Map<K, V> : 순서 없음 , 키 값 한 쌍으로 이루어지는 데이터 집합 , 키는 중복 불가 , 값은 중복 허용 , HashMap, TreeMap, Hashtable, Properties

  - <E> , <K, V> : 컬렉션 프레임워크를 구성하는 모든 클래스가 제네릭으로 표현되어 있음

컬렉션 클래스(collection class)
  - 컬렉션 프레임워크에 속하는 인터페이스를 구현한 클래스
  - 컬렉션 프레임워크의 모든 컬렉션 클래스는 List, Set, Map 인터페이스 중 하나의 인터페이스 구현하고 있음

    import java.util.*;

    public class Collection01 {
      public static void main(String[] args) {
        ArrayList<String> arrList = new ArrayList<String>();

        arrList.add("ㅋㅋㄹ");

        for(int i = 0; i < arrList.size(); i++) {
          sout(arrList.get(i));
        }
      }
    }

Collection 인터페이스
  - List와 Set 인터페이스의 많은 공통된 부분을 Collection 인터페이스에서 정의하고 그것을 상속받음
  - 컬렉션을 다루는데 가장 기본적인 동작들을 정의하고 메소드로 제공 중

  - boolean add(E e) : 해당 컬렉션에 전달된 요소 추가

  - void clear() : 해당 컬렉션의 모든 요소 제거

  - boolean contains(Object o) : 해당 컬렉션이 전달된 객체를 포함하고 있는지 확인

  - boolean equals(Object o) : 해당 컬렉션과 전달된 객체가 같은지 확인

  - boolean isEmpty() : 해당 컬렉션이 비어있는지 확인

  - Iterator<E> iterator() : 해당 컬렉션의 반복자 반환

  - boolean remove(Object o) : 해당 컬렉션에서 전달된 객체 제거

  - int size() : 해당 컬렉션 요소의 총 개수 반환

  - Object[] toArray() : 해당 컬렉션의 모든 요소를 Object 타입의 배열로 반환

  cf) Collection은 인터페이스, Collections는 클래스

-->

<!-- 
List 컬렉션 클래스
    - 요소의 저장 순서 유지
    - 같은 요소의 중복 저장 허용

    ArrayList<E> 클래스
      - 내부적으로 배열을 이용해 요소를 저장
      - 인덱스를 이용해 배열 요소에 빠르게 접근 가능
      - 배열은 크기를 변경할 수 없는 인스턴스이므로, 크기를 늘리기 위해 새로운 배열을 생성하고 기존의 요소들을 옮겨야하는 복잡한 과정을 거침
        => 자동으로 수행되지만, 요소의 추가 삭제 작업에 걸리는 시간이 매우 길어지는 단점이 생김

        ArrayList<Integer> arrList = new ArrayList<Integer>();

        arrList.add(10);
        arrList.remove(10);
        arrList.set(0, 20);

        for (int e : arrList) {
          sout(e)
        }

        Collections.sort(arrList);  // 요소 정렬

        Iterator<Integer> iter = arrList.iterator();  // iterator() 메소드와 get() 메소드로 요소 출력
        while (iter.hasNext()) {
          sout(iter.next());
        }

          
    LinkedList<E> 클래스
      - ArrayList 클래스가 배열을 이용하여 요소를 저장함으로써 발생하는 단점을 극복하기 위해 고안
      - 내부적으로 연결 리스트(linked list)를 이용하여 요소 저장
      - 배열은 저장된 요소가 순차적으로 저장되지만 연결 리스트는 저장된 요소가 비순차적으로 분포되며 요소들 사이를 링크로 연결하여 구성
      - 다음 요소를 가리키는 참조만 가지는 연결 리스트를 단일 연결 리스트라고 함
      - List 인터페이스를 구현하므로 ArrayList 클래스와 사용할 수 있는 메소드가 거의 같음 (ArrayList와의 차이는 내부적으로 요소를 저장하는 방법)

        단일 연결 리스트
          - 요소의 저장과 삭제 작업이 다음 요소를 가리키는 참조만 변경하면 되므로 아주 빠르게 처리될 수 있음
          - 현재 요소에서 이전 요소로 접근하기가 매우 어려움

        이중 연결 리스트
          - 이전 요소를 가리키는 참조도 가지고 좀 더 많이 사용됨
          - LinkedList 클래스는 이중 연결 리스트를 내부적으로 구현한 것

        LinkedList<String> lnkList = new LinkedList<String>();

        lnkList.add("ㅎㅇ")
        lnkList.remove(1);
        lnkList.set(2, "둘");
        
        for (String e : lnkList) {
          sout(e);
        }


    Vector<E> 클래스
      - JSK 1.0부터 사용해온 ArrayList 클래스와 같은 동작을 수행하는 클래스
      - 현재 Vector 클래스는 ArrayList 클래스와 마찬가지로 List 인터페이스를 상속받고 메소드가 거의 같음
      - 현재는 기존 코드와의 호환성을 위해서만 남아 있음.

    List 인터페이스 메소드
      - Collection 인터페이스 상속 받음

      - boolean add(E e) : 해당 리스트에 전달된 요소 추가

      - void add(int index, E e) : 해당 리스트의 특정 위치에 전달된 요소 추가

      - void clear() : 해당 리스트의 모든 요소 제거

      - boolean contains(Object o) : 해당 리스트가 전달된 객체를 포함하고 있는지 확인

      - boolean equals(Object o) : 해당 리스트와 전달된 객체가 같은지 확인

      - E get(int index) : 해당 리스트의 특정 위치에 존재하는 요소 반환

      - boolean isEmpty() : 해당 리스트가 비어있는지 확인

      - Iterator<E> iterator() : 해당 리스트의 반복자 반환

      - boolean remove(Object o) : 해당 리스트에서 전달된 객체 제거

      - boolean remove(int index) : 해당 리스트의 특정 위치에 존재하는 요소 제거

      - E set(int index, E e) : 해당 리스트의 특정 위치에 존재하는 요소를 전달받은 객체로 대체

      - int size() : 해당 리스트의 요소의 총 개수 반환

      - Object[] toArray() : 해당 리스트의 모든 요소를 Object 타입 배열로 반환

-->

<!-- 
Stack<E> 클래스
  - List 컬렉션 클래스의 Vector 클래스를 상속받아 전형적인 스택 메모리 구조의 클래스 제공
  - 스택 메모리 구조는 선형 메모리 공간에 데이터를 저장하면서 후입선출(LIFO)의 시멘틱을 따르는 자료 구조
  - 가장 나중에 저장된 데이터(push)가 가장 먼저 인출(pop)되는 구조

  - Stack<Integer> st = new Stack<Integer>();

  - 스택 메모리 구조를 표현하기 위해 Vector 클래스의 메소드를 5개만 상속받아 사용

    - boolean empty() : 해당 스택이 비어있으면 true, 비어있지않으면 false

    - E peek() : 해당 스택의 제일 상단에 있는, 마지막으로 저장된 요소를 반환

    - E pop() : 해당 스택의 제일 상단에 있는, 마지막으로 저장된 요소를 반환하고, 해당 요소를 스택에서 제거

    - E push(E item) : 해당 스택의 제일 상단에 전달된 요소를 삽입

    - int search(Object o) : 해당 스택에서 전달된 객체가 존재하는 위치의 인덱스 반환,
                            이때 인덱스는 제일 마지막으로 저장된 요소의 위치부터 0이 아닌 1부터 시작함
                            (맨 마지막 인덱스부터 0말고 1.. 2.. 3.. 이런 식 인듯)


  ArrayDeque 클래스
    - 더 복잡하고 빠른 스택 구현
    - Deque 인터페이스 구현
    - search() 메소드는 지원하지 않음
    - Deque<Integer> st = new ArrayDeque<Integer>();


    Stack<Integer> st = new Stack<Integer>();         // 스택 생성
    Deque<Integer> st2 = new ArrayDeque<Integer>();

    st.push(4);
    st.push(2);
    st.push(3);
    st.push(1);

    sout(st.peek());              // 1
    sout(st);                     // [4, 2, 3, 1]

    sout(st.pop());               // 1
    sout(st);                     // [4, 2, 3]

    sout(st.search(4));           // 3
    sout(st.search(3));           // 1



Queue<E> 인터페이스
  - 클래스로 구현된 스택과 달리 자바에서 큐 메모리 구조는 별도의 인터페이스 형태로 제공됨

  - Queue 인터페이스를 상속받는 하위 인터페이스
    - Deque<E>
    - BlockingDeque<E>
    - BlockingQueue<E>
    - TransferQueue<E>

  - Queue 인터페이스를 직간접적으로 구현한 클래스는 상당히 많음
  - Deque 인터페이스를 구현한 LinkedList 클래스가 큐 메모리 구조를 구현하는 데 가장 많이 사용됨

  - Queue 메모리 구조는 선형 메모리 공간에 데이터를 저장하면서 선입선출(FIFO)의 시멘틱을 따르는 자료 구조
  - 가장 먼저 저장된 데이터(push)가 가장 먼저 인출(pop)되는 구조

  - LinkedList<String> qu = new LinkedList<String>();

  - Queue 인터페이스는 큐 메모리 구조를 표현하기 위해 Collection 인터페이스 메소드만 상속받아 사용

    - boolean add(E e) : 해당 큐의 '맨 뒤'에 전달된 요소 삽입, 삽입 성공시 true, 큐에 여유공간이 없어 삽입에 실패하면 illegalStateException 발생

    - E element() : 해당 큐의 맨 앞에 있는, 제일 먼저 저장된 요소 반환

    - boolean offer(E e) : 해당 큐의 맨 뒤에 / 전달된 요소를 삽입

    - E peek() : 해당 큐의 맨 앞에 있는, 제일 먼저 저장된 요소 반환, 큐가 비어있으면 null 반환

    - E poll() : 해당 큐의 맨 앞에 있는, 제일 먼저 저장된 요소 반환 후 해당 요소를 큐에서 제거, 큐가 비어있으면 null 반환

    - E remove() : 해당 큐의 맨 앞에 있는, 제일 먼저 저장된 요소 제거


  ArrayDeque 클래스
    - 더 복잡하고 빠른 큐 구현
    - Deque<Integer> qu = new ArrayDeque<Integer>();

    LinkedList<String> qu = new LinkedList<String>();   // 큐 생성
    // Deque<String> qu = new ArrayDeque<String>(); 

    qu.add("넷")
    qu.add("둘")
    qu.add("셋")
    qu.add("하나")

    sout(qu.peek());  // 넷
    sout(qu);         // [넷, 둘, 셋, 하나]

    sout(qu.poll());  // 넷
    sout(qu);         // [둘, 셋, 하나]

    qu.remove("하나");
    sout(qu);         // [둘, 셋]

    cf) ArrayDeque 클래스는 스택과 큐 메모리 구조 모두 구현하는데 가장 적합한 클래스

-->

<!-- 
Deque<E>
  - Double-Ended Queue
  - 양쪽 끝에서 요소를 추가하거나 제거할 수 있음
  - 양방향 삽입 및 삭제 가능
  - 스택이나 큐로 사용할 수 있음
  - 예시 구현 클래스 : ArrayDeque, LinkedList

BlockingDeque<E>
  - Deque를 확장한 인터페이스
  - 스레드 간의 동기화 지원
  - 요소를 추가하거나 제거할 때, 큐가 비어있거나 가득 차 있을 경우 스레드를 블록시킬 수 있음
  - 멀티스레드 환경에서 안전하게 사용 가능
  - 주요 메소드 : offerFirst, offerLast, takeFirst, takeLast

BlockingQueue<E>
  - 스레드 간의 동기화를 지원하는 큐
  - 스레드가 큐에서 요소를 추가하거나 제거할 때, 큐의 상태에 따라 스레드를 블록시킬 수 있음
  - 주로 프로듀서-컨슈머 패턴에서 사용됨
  - 주요 구현 클래스 : ArrayBlockingQueue, LinkedBlockingQueue, PriorityBlockingQueue

TransferQueue<E>
  - BlockingQueue의 확장 인터페이스
  - 데이터를 소비할 준비가 된 스레드에만 데이터를 전송할 수 있음
  - transfer() 메소드를 통해 소비자가 대기 중일 때만 데이터 전달
  - 소비자가 대기중이지 않으면 transfer() 메소드는 소비자가 대기할 때까지 블록됨
  - 주요 구현 클래스 : LinkedTransferQueue

ArrayDeque
  - Deque 인터페이스를 구현한 클래스
  - 크기가 가변적인 배열로 구현된 덱
  - 빠른 요소 삽입 및 삭제 가능
  - 스레드에 안전하지 않음
  - 동기화가 필요하지 않은 상황에서 스택 또는 큐로 사용할 수 있음
  - LinkedList보다 메모리 효율성이 높고 성능이 뛰어남
-->

<!-- 
Set 컬렉션 클래스
  - 요소의 저장 순서를 유지하지 않음
  - 같은 요소의 중복 저장 불가

  HashSet<E> 클래스
    - 해시 알고리즘을 사용하여 검색 속도가 매우 빠름
    - 내부적으로 HashMap 인스턴스를 이용하여 요소 저장

    - 요소의 저장 순서를 바꿔도 저장되는 순서에는 영향을 미치지 않음
    - 이미 존재하는 요소를 추가하려고 하면, 해당 요소를 저장하지 않고 false 반환

      HashSet<String> hs = new HashSet<String>();

      hs.add("홍");
      hs.add("이");
      
      sout(hs.add("임"));
      sout(hs.add("임"));     // 저장 안됨

      for(String e : hs) {
        ...
      }

      Iterator<String> iter = hs.iterator();

      while(iter.hasNext()) {
        sout(iter.next());
      }

      sout(hs.size());

  TreeSet<E> 클래스
    - 데이터가 정렬된 상태로 저장되는 이진 검색 트리(binary search tree) 형태로 요소 저장
    - 이진 검색 트리는 데이터를 추가하거나 제거하는 등 기본 동작 시간이 매우 빠름
    - TreeSet 인스턴스에 저장되는 요소들은 모두 정렬된 상태로 저장됨

    - subSet() 메소드
      - public NavigableSet<E> subSet(E fromElement, E toElement)
        - 첫번째 매개변수로 전달된 값에 해당하는 요소부터 두번째 매개변수로 전달된 값에 해당하는 요소 바로 직전까지의 요소 반환

      - public NavigableSet<E> subSet(E fromElement, boolean frominclusive, E toElement, boolean toInclusive)
        - 두번째와 네번째 매개변수로 각각 첫번째 세번째 매개변수로 전달된 값에 해당하는 요소를 포함할 것인지 아닌지 명시 가능
        - 10(포함?미포함?) ~ 20(포함?미포함?) 이 얘기인듯?

  LinkedHashSet
    - 요소를 삽입한 순서를 유지 (순서를 유지하는 Set)
    - 이중 연결 리스트를 사용하여 요소의 순서를 기억함
    - 1, 2, 3 순서로 요소를 추가하면 반복(iteration)할 때도 이 순서가 유지됨
    - 중복 불가
    - HashSet과 마찬가지로 해시 기반으로 요소 관리
    - 요소의 순서를 유지하기 위해 이중 연결 리스트 구조를 사용하므로 HashSet에 비해 더 많은 메모리를 차지


  cf) Collection 인터페이스에서는 Iterator 인터페이스를 구현한 클래스의 인스턴스를 반환하는 iterator() 메소드를 정의하여 각 요소에 접근하도록 하고 있음.
-->

<!-- 
Map 컬렉션 클래스
  - Collection 인터페이스와 다른 저장 방식을 가짐
  - Map 인터페이스를 구현한 Map 컬렉션 클래스들은 키와 값을 하나의 쌍으로 저장하는 방식 사용 (key-value)
  - 키 : 값을 찾기 위한 이름

  - 요소의 저장 순서 유지하지 않음
  - 키는 중복 불가
  - 값은 중복 가능

  HashMap<K, V> 클래스
    - 해시 알고리즘을 사용하여 검색 속도가 매우 빠름

    HashMap<String, Integer> hm = new HashMap<String, Integer>();

    hm.put("십", 10);
    hm.put("일", 1);

    sout(hm.keySet());

    for(String key : hm.keySet()) {
        sout(String.format("키 : %s, 값 : %s", key, hm.get(key)));
    }

    hm.remove("십");

    Iterator<String> keys = hm.keySet().iterator();

    while(keys.hasNext()) {
      String key = keys.next();
      sout(String.format("키 : %s, 값 : %s", key, hm.get(key)));
    }

    hm.replace("십", 100);

    hm.size();

  HashTable<K, V>
    - HashMap 클래스와 같은 동작을 하는 클래스
    - 기존 코드와의 호환성을 위해서만 남아 있음

  TreeMap<K, V>
    - 키와 값을 한 쌍으로 하는 데이터를 이진 검색 트리 형태로 저장
    - 이진 검색 트리는 데이터를 추가하거나 제거하는 등 기본 동작 시간이 매우 빠름



    HashMap<K, V> 메소드

      - void clear() : 

      - boolean containsKey(Object key) : 

      - boolean containsValue(Object value) : 

      - V get(Object key) : 

      - boolean isEmpty() : 

      - Set<K> keySet() : 

      - V put(K key, V value) : 

      - V remove(Object Key) : 

      - boolean remove(Object key, Object value) : 

      - V replace(K key, V value) : 

      - boolean replace(K key, V oldValue, V newValue) : 

      - int size() : 



    TreeMap<K, V> 메소드

      - Map.Entry<K,V> ceilingEntry(K key) : 

      - K ceilingKey(K key) : 

      - void clear() : 

      - boolean containsKey(Object key) : 

      - boolean containsValue(Object Value) : 

      - NavigableMap<K, V> descendingMap() : 

      - Set<Map.Entry<K, V>> entrySet() : 

      - Map.Entry<K, V> firstEntry() : 

      - K firstKey() : 

      - Map.Entry<K, V> floorEntry(K key) : 

      - K floorKey(K key) : 

      - V get(Object key) : 

      - SortedMap<K, V> headMap(K toKey) : 

      - Map.Entry<K, V> higherEntry(K key) :
        
      - K higherKey(K key) : 

      - Set<K> keySet() : 

      - Map.Entry<K, V> lasyEntry() : 

      - K lastKey() : 

      - Map.Entry<K, V> lowerEntry(K key) : 

      - K lowerKey(K key) : 

      - Map.Entry<K, V> pollFirstEntry() : 

      - Map.Entry<K, V> pollLastEntry() : 

      - V put(K key, V value) : 

      - V remove(Object key) : 

      - boolean remove(K key, V value) : 

      - V replace(K key, V value) : 

      - boolean replace(K key, V oldValue, V newValue) : 

      - int size() : 

      - SortedMap<K, V> subMap(K fromKey, K toKey) : 

      - SortedMap<K, V> tailMap(K fromKey)

      cf) Map.Entry 인터페이스는 Map 인터페이스의 내부 인터페이스. 맵에 저장되는 엔트리의 조작을 위한 메소드가 정의되어 있음
      cf) 자바 공식 문서에서 키와 값으로 구성되는 데이터를 매핑(mapping) 또는 엔트리(entry)라고 기술함
--> 