<!-- 
메모리 구조
  - 모든 자바 프로그램은 자바 가상 머신(JVM)을 통해 실행
  - 자바 프로그램이 실행되면, JVM은 운영체제로부터 해당 프로그램을 수행할 수 있도록 필요한 메모리 할당 받음
  - 할당 받은 메모리를 JVM은 용도에 따라
    - 클래스, 클래스변수 : 메소드 영역
    - 객체, 인스턴스 : 힙 영역
    - 메소드, 지역 변수, 매개변수 : 스택 영역
    으로 관리

    메소드 영역
      - 자바 프로그램에서 사용되는 클래스에 대한 정보와 함께 클래스 변수(static variable)가 저장되는 영역
      - JVM은 자바 프로그램에서 특정 클래스가 사용되면 해당 클래스의 클래스 파일(*.class)를 읽어들여 해당 클래스에 대한 정보를 메소드 영역에 저장

    힙 영역
      - 자바 프로그램에서 사용되는 모든 인스턴스 변수가 저장되는 영역
      - JVM은 자바 프로그램에서 new 키워드를 사용하여 인스턴스가 생성되면, 해당 인스턴스의 정보를 힙 영역에 저장
      - 힙 영역은 메모리의 낮은 주소에서 높은 주소의 방향으로 할당됨    <- ?

    스택 영역
      - 자바 프로그램에서 메소드가 호출될 때 메소드의 스택 프레임이 저장되는 영역
        - 스택 프레임(stack frame) : 스택 영역에 저장되는 메소드의 호출 정보
      - JVM은 자바 프로그램에서 메소드가 호출되면, 메소드의 호출과 관계되는 지역 변수와 매개변수를 스택 영역에 저장
      - 스택 영역은 메소드의 호출과 함께 할당되며, 메소드의 호출이 완료되면 소멸함
      - 스택 영역은 푸시(push) 동작으로 데이터를 저장하고, 팝(pop) 동작으로 데이터를 인출함
      - 스택은 후입선출(LIFO, LAST-IN FIRST-OUT) 방식에 따라 동작하므로 가장 늦게 저장된 데이터가 가장 먼저 인출됨
      - 스택 영역은 메모리의 높은 주소에서 낮은 주소 방향으로 할당됨    <- ?

-->

<!-- 
배열(array)
  - 같은 타입의 변수들로 이루어진 유한 집합
  - 구성하는 값을 요소(element), 배열에서 위치를 가리키는 숫자 인덱스(index)
  - 자바에서 인덱스는 항상 0부터 시작 + 양의 정수만 가질 수 있음
  - 같은 종류의 데이터를 많이 다뤄야 하는 경우 사용할 수 있는 가장 기본적인 자료 구조
  - 선언 형식에 따라 1차원 배열, 2차원 배열, 다차원 배열
  - 자바에서는 배열도 모두 객체이므로, 각각 배열은 모두 자신만의 필드와 메소드를 가지고 있음
  - 배열의 길이를 초과하는 인덱스 사용시 ArrayIndexOutOfBounds 예외 발생
  - length : 배열의 길이를 저장하고 있는 배열 객체 필드

  1차원 배열
    - 타입[] 배열이름;  <- 추천됨
    - 타입 배열이름[];

    - 배열이름 = new 타입[배열길이];

    - 타입[] 배열이름 = new 타입[배열길이];

    배열 초기값
      - char : '\u0000'
      - byte, short, int : 0
      - long : 0L
      - float : 0.0F
      - double : 0.0 또는 0.0D
      - boolean : false
      - 배열, 인스턴스 : null

    배열 초기화
      - 초기화 블록(initialization block) : {}를 사용하여 초기값을 나열한 것
      - 타입[] 배열이름 = {배열요소1, 배열요소2, ...}
      - 타입[] 배열이름 = new 타입[]{배열요소1, 배열요소2, ...}
      - 위에 둘은 완전히 같은 결과 반환
      - 두번째 방법만으로 초기화해야 하는 경우
        - 배열의 선언과 초기화를 따로 진행해야 할 경우
        - 메소드의 인수로 배열을 전달하면서 초기화해야 할 경우
          ex)
            int[] a = {1,2,3};
            int[] a2 = new int[]{1,2,3};
            int[] a3;

            int[] a4;
            int[] a4 = new int[]{1,2,3} <- 이미 선언된 배열은 이 방법으로만 초기화할 수 있음

          ex)
            int[] a = new int[]{1,2,3};

            for (int i = 0; i < a.length; i++) { ... }

  다차원 배열
    - 2차원 이상의 배열
    - 배열 요소로 또 다른 배열을 가지는 배열
    - 2차원 배열은 1차원 배열을 가지는 배열, 3차원 배열은 2차원 배열을 가지는 배열 ...

    2차원 배열
      - 타입[][] 배열이름;
      - 타입 배열이름[][];
      - 타입[] 배열이름[];

      - 타입 배열이름[행 길이][열 길이] = {
          {배열요소[0][0], 배열요소[0][1], ...}
          {배열요소[1][0], 배열요소[1][1], ...}
          {배열요소[2][0], 배열요소[2][0], ...}
      }

        가변 배열
          - 2차원 배열을 생성할 때 열의 길이를 명시하지 않음으로써, 행마다 다른 길이의 배열을 요소로 저장할 수 있음
          - 행마다 다른 길이의 배열을 저장할 수 있는 배열을 가변 배열이라 함
          - 선언과 동시에 초기화도 가능
          ex)
              int[][] arr = new int[3][];
              arr[0] = new int[1];
              arr[1] = new int[2];
              arr[2] = new int[3000];

  배열 복사
    - 배열은 한 번 생성하면 길이 변경 불가
    - 더 많은 데이터를 저장하기 위해 더 큰 배열 만들고 이전 배열의 데이터를 새로 만든 배열로 복사해야 함
    - System 클래스 arraycopy() 메소드  (배열 복사만을 위해 만들어진 메소드. 가장 좋은 성능)
    - Arrays 클래스 copyOf() 메소드     (가장 많이 사용)
    - Object 클래스 clone() 메소드      (이전 배열과 같은 길이밖에 못 만듬)
    - for문 인덱스를 이용한 복사

    ex)
      int[] arr1 = new int[]{1,2,3,4,5};
      int newLen = 10;

      int[] arr2 = new int[newLen];
      System.arraycopy(arr1, 0, arr2, 0, arr1.length);

      int[] arr3 = Arrays.copyOf(arr1, 10);

      int[] arr4 = (int[])arr1.clone();

      향상된 for문
        - 명시한 배열이나 컬렉션의 길이만큼 반복되어 실행
        - 루프마다 각 요소는 명시한 변수의 이름으로 저장되며, 명령문에서 이 변수를 사용하여 각 요소를 참조할 수 있음
        - 요소를 참조할 때만 사용하는 것이 좋고 요소의 값을 변경하는 작업은 x
        - 향상된 for문 내부에서 사용되는 배열 요소는 배열 요소 그 자체가 아닌 배열 요소의 복사본이기 때문.

        int[] arr = new int[]{1,2,3,4,5};

        for (int e : arr) {
          e += 10;
        }

        결과: 1 2 3 4 5

-->