<!-- 
동적계획법
  - Dynamic Programming, DP
  - 복잡한 문제를 해결하기 위해 문제를 작은 부분 문제로 나누고, 
    각 부분의 문제의 결과를 저장하여 동일한 부분 문제를 다시 계산하지 않도록 하는 최적화 기법
  - 포인트는 부분 문제, 상태 정의, 점화식을 잘 설정하는 것

특징
  - 부분 문제로 나누기
    - 큰 문제를 해결하기 위해 동일한 유형의 작은 문제로 나눔
    - 피보나치 수열 F(n) = F(n-1) + F(n-2) 에서 오른쪽 항 부분이 작은 부분 문제
  
  - 중복 계산 제거
    - 이미 계산한 부분 문제의 결과를 저장해두고, 필요할 때 이를 재활용
    - 메모이제이션(Top-Down)이나 테이블 기반 계산(Bottom-Up)을 통해 중복 계산 방지

  - 최적 부분 구조
    - 문제를 작은 문제로 나눴을 때 작은 문제들의 최적 결과를 합쳐도 전체 문제의 최적 결과가 나옴
    - 경로 최적화 문제에서 특정 지점까지의 최단 거리를 알면, 전체 최단 거리를 계산할 수 있음

  - 결과 저장 (캐싱)
    - 작은 문제의 결과를 저장하여 동일한 계산을 반복하지 않도록 함
    - 배열, HashMap 이용

문제 해결
  - 문제를 부분 문제로 나누기
    - 큰 문제를 작은 문제로 나눌 수 있는 방법 찾기
    - ex) 피보나치 수열 : F(n) = F(n-1) + F(n-2)

  - 상태 정의
    - DP 테이블(배열)의 각 인덱스가 무엇을 의미하는지 정의
    - ex) dp[i]를 i번째까지의 최적값이라고 정의

  - 점화식(Recurrence Relation) 만들기
    - dp[i]를 이전 상태 dp[i-1], dp[i-2] 등으로 표현
    - ex) dp[i] = dp[i-1] + dp[i-2]

  - 초기값 설정
    - dp[0] = 0, dp[1] = 1

  - DP 테이블 채우고 결과 출력
    - 작은 문제부터 차례로 계산하여 DP 배열을 채움

구현 방식
  - Top-Down 방식
    - 큰 문제를 재귀적으로 작은 문제로 나누어 풀고 이미 계산한 값 저장
    - 코드가 직관적, 점화식에 기반한 논리를 쉽게 구현 가능
    - 스택 호출이 많아질 경우 메모리 사용량 증가

      public class Topdown {
        static int[] dp

        public static int fibonacci(int n) {
          if (n <= 1) return n;

          if (dp[n] != -1) return dp[n];

          dp[n] = fibonacci(n - 1) + fibonacci(n - 2);
          
          return dp[n];
        }

        public static int main(String[] args) {
          int n = 10;
          dp = new int[n + 1];
          Arrays.fill(dp, -1);

          sout("fibonacci n = " fibonacci(n));
        }
      }

      ---

      public class Fibonacci {
        static HashMap<Integer, Integer> memo = new HashMap<>();

        public static int fib(int n) {
          if (n <= 1) return n;
          if (memo.containsKey(n)) return memo.get(n);

          int result = fib(n - 1) + fib(n - 2);

          memo.put(n, result);

          return result;
        }

        public static void main(String[] args) {
          sout(fib(10));
        }
      
      }

  - Bottom-Up 방식
    - 작은 문제부터 차례대로 계산하여 큰 문제 해결
    - 스택 오버 플로 방지, 메모리 사용량이 적음
    - 코드가 직관적이지 않을 수 있음

    public class bottomUp {
      public static void main(String[] args) {
        int n = 10;
        int[] dp = new int[n + 1];

        dp[0] = 0;
        dp[1] = 1;

        for (int i = 2; i <= n; i++) {
          dp[i] = dp[i - 1] + dp[i - 2];    // 점화식
        }

        sout("fibonacci n = " + dp[n]);
      }
    }

-->