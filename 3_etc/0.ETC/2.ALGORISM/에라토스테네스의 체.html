<!-- 
에라토스테네스의 체
  - 소수를 효율적으로 구하는 고대의 알고리즘
  - 2부터 특정 숫자 n까지의 소수를 찾을 때 사용됨
  - 반복적으로 배수를 제거하여 소수를 찾음
  - 마치 체로 치듯이 수를 걸러낸다고 하여 명명

  소수
    - 1과 자기 자신만을 약수로 가지는 숫자 (ex: 2, 3, 5, 7, 11, 13)

  시간 복잡도
    - O(n log log n)
      - 각 소수 p에 대해 n/p의 연산이 수행 (p : 현재 작업중인 소수 2, 3, ..)
      - 작은 소수에 대해 더 많은 연산이 이루어지므로 전체 복잡도는 n log log n이 됨

      - n log log n ?
        - n : 입력 크기 (1부터 n까지의 소수 구하기) = n은 찾고자 하는 숫자의 최대값
        
        - log : 수학에서 어떤 숫자를 나타내기 위해 몇 번 곱해야 하는지 말함
        
        - log n : log2^8 = 3 (2를 3번 곱하면 8이 됨)
        
        - log log n : log 16 = 4 , log log 16 = 2 = n이 매우 클 때 log n 보다 훨씬 천천히 증가함
        
        - n log log n
          - n개의 숫자 중에서 소수인지 확인하기 위해 필요한 연산의 총 합
          - 에라토스테네스의 체에서 n의 크기가 커질수록 소수의 밀도는 줄어들지만, 소수의 배수를 제거하는 연산은 여전히 필요하기 때문에
            n log log n이 됨
          - n은 우리가 소수를 구하려는 최대 숫자, 로그 로그 값만큼의 연산을 반복적으로 수행한다는 의미
          - log log n은 소수를 구하기 위해 각 숫자에서 발생하는 평균적 연산량

  공간 복잡도
    - O(n)
      - 숫자 범위를 저장하기 위해 n 크기의 배열 필요

  장점
    - 간단한 구조로 대규모 소수를 빠르게 구할 수 있음
    - n이 커질수록 효율성 증가

  단점
    - O(n)의 공간을 사용하므로 n이 매우 크면 메모리가 부족할 수 있음
    - 매우 큰 숫자에 대해서는 Segmented Sieve 같은 알고리즘 필요
    - '특정 범위 내의 소수'를 판정하는 데에만 효율적 (주어진 수 하나가 소수인가? 만을 따지는 상황에서 더 효율적인 방법 많음)
    
  예시

    의사코드
      - n까지의 배열을 만든다. (2부터 n까지)
      - 2부터 시작하여 현재 숫자가 소수라면 그 숫자의 배수를 제거한다.
      - 루트n까지 반복
      - 남아 있는 숫자가 소수

    public class SieveOfEratosthenes {
      public static void main(String[] args) {
      
      int n = 50;
      boolean[] isPrime = new boolean[n + 1];

      Arrays.fill(isPrime, true);                   // 모든 숫자를 처음은 소수로 간주함
      isPrime[0] = isPrime[1] = false;              // 0과 1은 소수 x

      for (int i = 2; i * i <= n; i++) {            // 조건식 : i^2가 n보다 크면 i의 배수가 더이상 n보다 크지 않다는 말이므로 조건 종료 (n보다 작아야 됨)
        if (isPrime[i]) {                           
          for (int j = i * i; j <= n; j += i) {     // 초기값 : i부터 시작하면 이미 제거된 숫자들을 다시 확인하게 되므로 i^2부터 시작
            isPime[j] = false;                      // 2일 경우 4 6 8 부터 시작, 소수인 2 3 5 7은 제거안됨
          }
        }
      }

      for (int i = 2; i <= n; i++) {
        if (isPrime[i]) {
          sout(i + " ");
        }
      }
      

      }
    }



-->