<!-- 
최대힙
  - 완전 이진 트리 형태의 자료 구조
  - 모든 레벨이 꽉 차 있어야 하며, 마지막 레벨에서는 왼쪽부터 차례대로 채워야 함
  - 빈 공간 없이 아래로 채워진 이진 트리 구조
  - 부모 노드의 값은 항상 자식 노드의 값보다 크거나 같음
  - 루트 노드에는 항상 트리의 최대값이 위치함

동작
  - 삽입
      - 새로운 값을 트리의 마지막 자리에 삽입
      - 부모 노드와 비교하여 최대 힙 규칙을 만족하도록 값을 위로 올림 (Heapify-Up 또는 Shift-Up)

    삭제
      - 최대 힙에서 항상 루트 노드(최대값)를 삭제 
      - 트리의 마지막 노드를 루트 자리에 이동시킴
      - 자식 노드와 비교하여 최대 힙 규칙을 만족하도록 값을 아래로 내림 (Heapify-Down 또는 Shift-Down)

시간 복잡도
  - 삽입&삭제
    - 트리의 높이만큼 연산이 필요함
    - 높이 : O(log N)

  - 최대값 조회
    - 루트 노드는 항상 최대값
    - O(1)로 조회 가능

구현
  - 배열을 사용해 구현
  - 트리 구조를 인덱스 기반으로 표현할 수 있음
  - 노드의 인덱스 i
      - 부모노드 : parent[i] = (i-1) / 2
      - 왼쪽자식노드 : left[i] = 2i + 1
      - 오른쪽자식노드 : right[i] = 2i + 2

예시
      50
  30      20
15  10  8    5

[50, 30, 20, 15, 10, 8, 5]

활용
  - 우선순위 큐 : 큰 값(높은 우선수위)이 먼저 처리되는 작업
  - 힙 정렬 : 최대 힙을 활용하여 정렬 수행
  - 최대값 추출 : 주어진 데이터에서 가장 큰 값을 빠르게 찾고 제거해야 하는 경우

-->

<!-- 
PriorityQueue
  - 우선순위에 따른 정렬
    - 기본적으로 최소힙 구조로 구현되어 있음
    - 기본 설정에서는 작은 값이 우선순위가 높음
    - 커스텀 Comparator를 사용하면 최대 힙 또는 다른 기준으로 정렬할 수 있음

  - 동작 원리
    - 내부적으로 힙(Heap) 자료구조를 사용하여 요소 관리
  
  - 중복 값 허용

  - 비동기적 구조
    - 스레드 안전을 지원하지 않으므로 다중 스레드 환경에서 동기화 필요

  - 메소드
    - add(E e), Offer(E e) : 요소를 큐에 삽입, 우선순위에 따라 위치가 자동으로 결정
    - poll() : 우선순위가 가장 높은 요소 제거 후 반환
    - peek() : 큐에서 우선순위가 가장 높은 요소를 반환
    - remove(Object o) : 지정된 객체를 큐에서 제거
    - size() : 큐에 있는 요소 개수 반환
    - isEmpty() : 큐가 비어있는지 확인

구현
  PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());

  maxHeap.add(50);
  maxHeap.add(20);
  maxHeap.add(30);
  maxHeap.add(10);

  sout("PriorityQueue (Max-Heap): " + maxHeap);         // [50, 20, 30, 10]

  sout("poll(): " + maxHeap.poll());                    // 50 (최대값)     
  sout("peek(): " + maxHeap.peek());                    // 30 (최대값)     
  sout("PriorityQueue after poll(): " + maxHeap);       // [30, 20, 10]
    }

-->