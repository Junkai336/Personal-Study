<!-- 

  연산자

    연산자 우선순위
      1. INTERVAL
      2. BINARY, COLLATE
      3. !
      4. - (단항 연산자), ~ (비트 연산자)
      5. ^
      6. *, /, DIV, %, MOD
      7. -(이항 연산자), +
      8. <<, >>
      9. &
      10. |
      11. = (관계 연산자), <=>, >=, >, <=, <, <>, !=, IS, LIKE, REGEXP, IN
      12. BETWEEN, CASE, WHEN, THEN, ELSE
      13. NOT
      14. AND, &&
      15. XOR
      16. OR, ||
      17. = (대입연산자), := 

    산술연산자
      - + : 왼쪽 피연산자에 오른쪽 피연산자 더함
      - - : 왼쪽 피연산자에 오른쪽 피연산자 뺌
      - * : 왼쪽 피연산자에 오른쪽 피연산자 곱함
      - / : 왼쪽 피연산자를 오른쪽 피연산자로 나눔

      - DIV : 왼쪽 피연산자를 오른쪽 피연산자로 나눈 후, 소수 부분 버림
      - % or MOD : 왼쪽 피연산자를 오른쪽 피연산자로 나눈 후, 나머지 반환



    대입연산자
      - = : 왼쪽 피연산자에 오른쪽 피연산자를 대입함 (SET문, UPDATE문의 SET절에서만 대입연산자로 사용됨)
      - := : 왼쪽 피연산자에 오른쪽 피연산자를 대입함 (SET문, UPDATE문의 SET절 이외에서 사용됨) {절대로 비교 연산자로 해석되지 않음}



    비교 연산자
      - 피연산자 사이의 상대적인 크기를 판단하여, 참이면 1, 거짓이면 0 반환
      - = : 왼쪽 피연산자와 오른쪽 피연산자가 같으면 참
      - !=, <> : 왼쪽 피연산자와 오른족 피연산자가 같지 않으면 참
      - < : 오른쪽 피연산자가 더 크면 참
      - <= : 오른쪽 피연산자가 더 크거나 같으면 참
      - > : 왼쪽 피연산자가 더 크면 참
      - >= : 왼쪽 피연산자가 더 크거나 같으면 참

      - <=> : 양쪽 피연산자가 모두 NULL 이면 참 , 하나의 피연산자만 NULL이면 거짓

      - IS : 왼쪽 피연산자와 오른쪽 피연산자가 같으면 참 (오른쪽 피연산자가 불리언 값인 TRUE, FALSE, UNKNOWN 값일 때 사용)
      - IS NOT : 왼쪽 피연산자와 오른쪽 피연산자가 같지 않으면 참 (ㅣㅣ)

      - IS NULL : 피연산자의 값이 NULL이면 참
      - IS NOT NULL : 피연산자의 값이 NULL이 아니면 참

      - BETWEEN min AND max : 피연산자의 값이 min 보다 크거나 같고 , max 보다 작거나 같으면 참
      - NOT BETWEEN min AND max : 피연산자의 값이 min 보다 작거나 , max 보다 크면 참

      - IN() : 피연산자의 값이 인수로 전달받은 리스트에 존재하면 참
          ex) 5 IN (2, 3, 4, 5) : 5가 2,3,4,5 중에 포함되는지 비교함 (비교연산자는 참이면 1을 반환한다.)
      - NOT IN() : 피연산자의 값이 인수로 전달받은 리스트에 존재하지 않으면 참



    논리 연산자
      - 참이면 1 , 거짓이면 0
      - AND, && : 논리식이 모두 참이면 참
      - OR, || : 논리식이 하나라도 참이면 참
      - XOR : 논리식이 서로 다르면 참
      - NOT, ! : 논리식이 참이면 거짓 , 논리식이 거짓이면 참

    비트 연산자
      - 논리 연산자와 비슷하지만, 비트(bit) 단위로 논리 연산 수행
      - & : 대응되는 비트가 모두 1이면 1 반환 (AND 연산)
      - | : 대응되는 비트 중 하나라도 1이면 1 반환 (OR 연산) {비트에 1이 포함되어 있는 개념 1000 | 1111}
      - ^ : 대응되는 비트가 서로 다르면 1 반환 (XOR 연산)
      - ~ : 비트를 1이면 0으로, 0이면 1로 반전시킴 (NOT 연산)
      - << : 지정한 수만큼 비트를 전부 왼쪽으로 이동시킴
      - >> : 부호를 유지하면서 지정한 수만큼 비트를 전부 오른쪽으로 이동시킴

      ex) SELECT b '1000' & b '1111' -> 첫 번째 비트만이 둘 다 1이므로, 연산 결과는 b'1000'이 됨. <- ?
-->

<!-- 
  흐름제어
    - 프로그램의 순차적인 흐름을 제어해야 할 때 사용할 수 있음

    - CASE
      - 값을 서로 비교하거나, 표현식의 논리값에 따라 다른 값을 반환
      - CASE value
          WHEN [compare_value] THEN result
          WHEN [compare_value] THEN result ...
          [ELSE result]
          END
            => value 와 compare_value 값이 같으면 THEN 절의 result 값 반환
            => 같지 않으면 ELSE 절의 result 값 반환
            => ELSE 절이 없으면 NULL 반환

      - CASE
        WHEN [condition] THEN result
        [WHEN [condition] THEN result] ...
        [ELSE result]
        END
          => condition 논리값이 참이면 then 절의 result 반환
          => 논리값이 거짓이면 result 값 반환
          => ELSE 절이 없으면 NULL 반환

    - IF()
      - 첫번째 인수로 전달받은 표현식의 논리값에 따라 다른 값 반환
      - IF(expr1, expr2, expr3)
      - expr1이 참이면 expr2 반환
      - expr1이 거짓이면 expr3 반환
      ex) SELECT IF(0 < 1, 'yes', 'no');

    - IFNULL()
      - 첫번째 인수로 전달받은 겂아 NULL인지 아닌지 검사하여 다른 값 반환
      - IFNULL(expr1, expr2)
      - expr1이 NULL이 아니면 expr1 반환
      - expr1이 NULL이면      expr2 반환
      ex) SELECT IFNULL(NULL, "전달받은 값이 NULL임");

    - NULLIF()
      - 인수로 전달받은 두 값이 서로 같은지 검사하여 다른 값 반환
      - NULLFIF(expr1, expr2)
      - expr1과 expr2의 값이 서로 같으면 NULL
      - 같지 않으면 expr1 반환
      ex) CASE
            WHEN expr1 = expr2
            THEN NULL
            ELSE expr1
          END

          SELECT NULLIF(3, 3) = NULL
-->

<!-- 
  패턴매칭
    - 특정 패턴을 검색하기 위한 패턴 매칭 연산자
    - 임의의 문자나 문자열을 대체하기 위해 와일드카드 문자를 사용할 수 있음

    - LIKE
      - 특정 패턴을 포함하는 데이터만 검색하기 위해 사용
      - '%' : 0개 이상의 문자라는 의미의 와일드카드 문자
      - NOT LIKE : 특정 패턴을 포함하지 않는 데이터 검색

      - 와일드카드
        - % : 0개 이상의 문자를 대체함
        - _ : 1개의 문자를 대체함

    - REGEXP
      - LIKE 연산자보다 더 복잡한 패턴 검색
      - 정규표현식을 토대로 패턴 매칭 연산 제공

      - 패턴
        - . : 줄바꿈 문자(\n)를 제외한 임의의 한 문자

        - * : 해당 문자 패턴이 0번 이상 반복
        - + : 해당 문자 패턴이 1번 이상 반복

        - ^ : 문자열의 처음
        - $ : 문자열의 끝

        - | : 선택을 의미 (OR)

        - [...] : 괄호[] 안에 있는 어떠한 문자를 의미
        - [^...] : 괄호[] 안에 있지 않은 어떠한 문자를 의미

        - {n} : 반복되는 횟수를 지정
        - {m,n} : 반복되는 횟수의 최솟값과 최댓값을 지정

        ex) SELECT * FROM ~ WHERE NAME REGEXP '^홍|산$'; : 홍으로 시작하거나, 산으로 끝나는 레코드 선택

        - NOT REGEXP : 해당 패턴과 일치하지 않는 데이터 찾기
-->

<!-- 
  타입 변환
    - 비교나 검색을 수행할 때 데이터 타입이 서로 다를 경우, 내부적으로 타입이 같아지도록 자동 변환하여 처리하지만,
    - 사용자가 명시적으로 타입을 변환할 수 있도록 연산자, 함수 제공하기도 함

    - BINARY
      - 뒤에 오는 문자열을 바이너리 문자열로 변환
      - 문자가 아닌 바이트를 기준으로 비교나 검색 작업 수행 가능
      - 비교하려는 문자의 '바이트 값'을 비교
      ex) SELECT BINARY 'a' = 'A', 'a' = 'A'
                            0          1

    - CAST()
      - 인수로 전달받은 값을 명시된 타입으로 변환하여 반환
      - 변환하고자 하는 타입을 AS 절로 직접 명시 가능
      - CAST(expr AS type)
      - ex) SELECT 4 / '2', 4 / 2, 4 / CAST('2' AS UNSIGNED);
        =>            2 ,   2.0000 ,        2.0000

      - AS 절에서 사용할 수 있는 타입
        - BINARY
        - CHAR
        - DATE
        - DATETIME
        - TIME
        - DECIMAL
        - JSON
        - NCHAR
        - SIGNED [INTEGER]
        - UNSIGNED [INTEGER]

    - CONVERT()
      - 인수로 전달받은 값을 명시된 타입으로 변환하여 반환
      - 두번째 인수로 변환하고자 하는 타입을 직접 전달할 수 있음
      - CONVERT(expr, type)
      - CONVERT(expr USING transcoding_name)
        - USING 절 : 서로 다른 문자셋(character set) 간의 데이터 변환을 위해 사용
        - 이 때 사용할 수 있는 타입은 CAST() 함수와 같음
      ex) SELECT CONVERT('abc' USING utrf8)
-->

<!-- 
  제약조건
    - 데이터의 무결성을 지키기 위해, 데이터를 입력받을 때 실행되는 검사 규칙

    - NOT NULL
      - 해당 필드는 NULL 값을 저장할 수 없음
      - 이 제약 조건이 설정된 필드는 무조건 데이터를 가지고 있어야 함
      - CREATE문, ALTER문으로 추가할 수 있음
      - 해당 필드에 NULL 값을 저장할 수 없도록 설정하는 것으로, 해당 필드를 생략하지 못하도록 하는 제약 조건은 아님 
        (INSERT 문으로 레코드 저장할 때 NOT NULL 제약 조건이 설정된 필드의 값을 생략할 수도 있음) <- 생략하면 0 저장되는듯?
      ex:
        CREATE TABLE 테이블이름 
          (
          필드이름 필드타입 NOT NULL,
          ...
          )
      ex:
        ALTER TABLE 테이블이름
          ADD 필드이름 필드타입 NOT NULL
          MODIFY COLUMN 필드이름 필드타입 NOT NULL

    - UNIQUE
      - 해당 필드는 서로 다른 값을 가져야 함
      - 중복된 값을 저장할 수 없음
      - CREATE문, ALTER문으로 추가할 수 잇음
      ex:
        CREATE TABLE 테이블이름
        (
          필드명 필드타입 UNIQUE,
          ...
        )
          => 해당 필드에 UNIQUE 제약 조건 설정
      ex:
        CREATE TABLE 테이블이름
        (
          필드명 필드타입,
          ...
          [CONSTRAINT 제약조건이름] UNIQUE (필드이름)
        )
          => 해당 제약 조건에 이름을 설정할 수 있음

      ex:
        ALTER TABLE 테이블이름
          ADD 필드이름 필드타입 UNIQUE
        
        ALTER TABLE 테이블이름
          ADD [CONSTRAINT 제약조건이름] UNIQUE (필드이름)

        ALTER TABLE 테이블이름
          MODIFY COLUMN 필드이름 필드타입 UNIQUE

        ALTER TABLE 테이블이름
          MODIFY COLUMN [CONSTRAINT 제약조건이름] UNIQUE (필드이름)

    - 제약조건에 이름 설정할 경우, 이름을 사용하여 제약 조건을 삭제할 수 있음
      ex:
        ALTER TABLE 테이블이름
          DROP INDEX 제약조건이름

      

    - PRIMARY KEY

    - FOREIGN KEY

    - DEFAULT

-->