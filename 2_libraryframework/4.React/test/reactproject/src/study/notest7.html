<!-- 

    Hook

        Hook?
            - 클래스 컴포넌트를 작성할 필요 없이 함수 컴포넌트에서도 state 관리와 생명주기(lifecycle) 메소드 등 여러 다양한 React 기능 사용 가능
            - state, context, ref, lifecycle 등 다양한 React 개념을 사용자가 손쉽게 사용할 수 있도록 좀 더 직관적인 API(내장 Hook)을 제공함
            - 컴포넌트 사이의 state 관련 로직을 재사용하기 위해 사용자가 직접 자신만의 Hook을 만들어 사용할 수 있음

        Hook 특징
            - 컴포넌트로부터 state 관련 로직을 추상화 할 수 있고 이를 활용하여 독립적인 테스트와 로직의 재사용이 가능해짐
            - state 관련 로직과 사이드 이펙트(side effect) 등이 포함된 복잡한 컴포넌트를 유지보수가 쉬워지도록 비슷한 동작을 하는 컴포넌트들로 나누어 관리 가능
            - 이전 버전의 React(v16.8이전) 과도 호환되므로 클래스 컴포넌트 기반으로 구현된 기존의 React 프로젝트에도 Hook을 점진적으로 도입할 수 있음
        
        Hook 사용 규칙
            - 반복문, 조건문, 중첩된 함수 등에서 호출해서는 안됨
            - 반드시 컴포넌트의 최상위 레벨에서 호출해야 함
            - 일반 자바스크립트 함수에서 호출해서는 안되며 React의 함수 컴포넌트 내에서만 호출해야 함
            - (사용자 정의 Hook 내에서도 Hook을 호출할 수 있음)

        내장 Hooks(built-in hooks)
            - React에서 기본적으로 제공하고 있는 내장 Hook

            1. State Hooks



            2. Context Hooks



            3. Ref Hooks



            4. Effect Hooks



            5. Performance Hooks
                - 리렌더링 성능을 최적화하는 일반적인 방법은 불필요한 작업을 건너뛰는 것
                - 직전에 렌더링한 이후 데이터가 변경되지 않았다면 캐시된 데이터를 재사용하거나 리렌더링을 건너뛰도록 설정할 수 있음
                - 데이터를 캐시하려면 useMemo나 useCallback을 사용할 수 있음
                - 렌더링 우선 순위를 지정하려면 useTransition이나 useDeleredValue를 사용할 수 있음

                - React에서 데이터를 캐시하려면 다음 Hook 중 하나 사용
                    - useMemo : 이전에 수행한 계산 결과를 캐시하여 재사용할 수 있음
                    - useCallback : 이미 만들어 놓은 함수를 캐시하여 재사용할 수 있음



                useMemo Hook
                    - 이전에 수행한 계산 결과를 캐시해 놓으면, 컴포넌트 내부에서 발생하는 연산 작업을 최적화할 수 있음
                    - 렌더링하는 과정에서 특정 값이 바뀌었을 때만 연산을 실행하고, 해당 값이 바뀌지 않았다면 캐시해 놓은 이전 계산 결과를 그대로 재사용하는 방식으로 최적화 수행

                    const cachedValue = useMemo(calculateValue, dependencies)
                        - 첫번째 인수 : 해당 값을 계산하는 함수
                        - 두번째 인수 : 배열을 전달받음. 전달 받은 배열에 포함된 값이 변경되면 첫번째 인수로 전달된 함수를 호출하여 해당 값을 계산하고, 값이 변경되지 않았다면 이전에 연산한 값 그대로 재사용



                useCallback Hook
                    - 이전에 정의해 놓은 함수를 캐시해 놓음으로써, 렌더링 성능 최적화 가능
                    - 리렌더링 간 함수의 정의를 캐시하여 필요한 때 해당 함수를 재생성하는 방식으로 최적화 수행

                    const cachedFn = useCallback(fn, dependencies)
                        - 첫번째 인수 : 생성하고 싶은 함수의 정의
                        - 두번째 인수 : 배열, 이 배열에는 어떤 값이 바뀌었을 때 함수를 새로 생성해야 하는지 명시

-->