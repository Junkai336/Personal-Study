<!-- 

    Hook

        Hook?
            - 클래스 컴포넌트를 작성할 필요 없이 함수 컴포넌트에서도 state 관리와 생명주기(lifecycle) 메소드 등 여러 다양한 React 기능 사용 가능
            - state, context, ref, lifecycle 등 다양한 React 개념을 사용자가 손쉽게 사용할 수 있도록 좀 더 직관적인 API(내장 Hook)을 제공함
            - 컴포넌트 사이의 state 관련 로직을 재사용하기 위해 사용자가 직접 자신만의 Hook을 만들어 사용할 수 있음

        Hook 특징
            - 컴포넌트로부터 state 관련 로직을 추상화 할 수 있고 이를 활용하여 독립적인 테스트와 로직의 재사용이 가능해짐
            - state 관련 로직과 사이드 이펙트(side effect) 등이 포함된 복잡한 컴포넌트를 유지보수가 쉬워지도록 비슷한 동작을 하는 컴포넌트들로 나누어 관리 가능
            - 이전 버전의 React(v16.8이전) 과도 호환되므로 클래스 컴포넌트 기반으로 구현된 기존의 React 프로젝트에도 Hook을 점진적으로 도입할 수 있음
        
        Hook 사용 규칙
            - 반복문, 조건문, 중첩된 함수 등에서 호출해서는 안됨
            - 반드시 컴포넌트의 최상위 레벨에서 호출해야 함
            - 일반 자바스크립트 함수에서 호출해서는 안되며 React의 함수 컴포넌트 내에서만 호출해야 함
            - (사용자 정의 Hook 내에서도 Hook을 호출할 수 있음)

        내장 Hooks(built-in hooks)
            - React에서 기본적으로 제공하고 있는 내장 Hook

            1. State Hooks
                - React 컴포넌트는 state를 활용하여 가변적인 상태(state)를 기억할 수 있음
                - 사용자 입력을 저장하기 위해, 현재 카운터를 저장하기 위해 등 사용할 수 있음
                
                - state를 추가하기 위한 Hook
                    - useState : 사용자가 직접 업데이트할 수 있는 state 변수 선언
                    - useReducer : reducer 함수 내부의 업데이트 로직을 사용하여 state 변수를 선언



                    useState Hook
                        - const [state, setState] = useState(initialState)
                        - 처음 렌더링을 수행할 때 초기 상태 값(initialState)을 인수로 전달 받고, 최신 state 값을 유지하는 변수와 그 값을 업데이트할 수 있는 함수 반환

                        ex)

                        import {useState} from "react";

                        const Counter = () => {
                            comst [state, setState] = useState(0);
                            
                            return (
                                <div>
                                    <h1>State 값 : {state}</h1>
                                    <button onClick={() => setState(state + 1)}>1씩 증가</button>
                                </div>
                                );
                            };

                        export default Counter;
                                


                    useReducer Hook
                        - const [state, dispatch] = useReducer(reducer, initialArg, init?)
                        - useState보다 좀 더 복잡한 상황에서 state를 사용할 수 있도록 컴포넌트와 state의 업데이트 로직을 서로 분리시켜 관리 가능
                        - 첫번째 인수 : reducer 함수를 전달 받음
                        - 두번째 인수 : reducer의 기본값 전달 받음
                        - 현재 state 값과 action을 발생시키는 dispatch 함수를 반환함
                        - useReducer가 반환하는 dispatch 함수를 사용하면 state를 다른 값으로 업데이트하고 리렌더링하도록 설정할 수 있음
                        - dispatch 함수에는 인수로 action 값을 전달해야 함
                        - useReducer를 사용했을 때 장점은 컴포넌트에서 state 업데이트 로직을 컴포넌트 외부로 분리시킬 수 있다는 점

                        ex)

                        import { useReducer } from "react";

                        // 컴포넌트와 분리된 state 업데이트 로직
                        const reducer = (state, action) => {
                            if (action.type === "increment") {
                                return {
                                    count: state.count + 1
                                };
                            }
                        };

                        const Counter = () => {
                            const [state, dispatch] = userReducer(reducer, { count: 0 });

                            return (
                                <div>
                                    <h1>State 값 : {state.count}</h1>
                                    // dispatch 함수에 action.type 값으로 'increment'를 전달하여 리렌더링시킴
                                    <button onClick={() => dispatch({ type: "increment "})}>1씩 증가</button>
                                </div>
                            )
                        }


            2. Context Hooks



            3. Ref Hooks
                - const ref = useRef(initialValue)
                - ref를 활용하여 특정 DOM 노드를 선택하거나 컴포넌트 내의 변수를 관리할 수 있도록 해줌
                - 인수로 전달된 값(initialValue)으로 초기화 된 변경 가능한 ref 객체를 반환
                - 이 객체는 컴포넌트의 전 생명 주기동안 유지됨
                - ref 객체는 current라는 프로퍼티 하나만 가지고 있으며, 이 current 값이 실제 엘리먼트를 가리키게 됨

                ex) 
                    import { useState, useRef } from 'react';
                    import video from "./flower.mp4";

                    const VideoPlay = () => {
                        const [isPlaying, setIsPlaying] = useState(false);
                        const ref = useRef(null);

                        // ref.current로 재생 중이면 pause, 정지 중이면 play로 
                        const handleClick = (0 => {
                            if(isPlaying) {
                                ref.current.pause();
                            } else {
                                ref.current.play();
                            }

                            // not 연산자로 boolean 반대로 만들기
                            setIsPlaying(!isPlaying);
                        };

                    }




            4. Effect Hooks
                
                사이드 이펙트(side effects)
                    - 일부 React 컴포넌트는 화면에 표시되는 동안 네트워크, 브라우저 API 또는 다른 라이브러리와 연결된 상태를 유지해야 하는 경우가 발생할 수 있음
                    - 이렇게 React에 의해 제어되지 않는 시스템을 외부 시스템(external system)이라고 부름



            5. Performance Hooks
                - 리렌더링 성능을 최적화하는 일반적인 방법은 불필요한 작업을 건너뛰는 것
                - 직전에 렌더링한 이후 데이터가 변경되지 않았다면 캐시된 데이터를 재사용하거나 리렌더링을 건너뛰도록 설정할 수 있음
                - 데이터를 캐시하려면 useMemo나 useCallback을 사용할 수 있음
                - 렌더링 우선 순위를 지정하려면 useTransition이나 useDeleredValue를 사용할 수 있음

                - React에서 데이터를 캐시하려면 다음 Hook 중 하나 사용
                    - useMemo : 이전에 수행한 계산 결과를 캐시하여 재사용할 수 있음
                    - useCallback : 이미 만들어 놓은 함수를 캐시하여 재사용할 수 있음



                useMemo Hook
                    - 이전에 수행한 계산 결과를 캐시해 놓으면, 컴포넌트 내부에서 발생하는 연산 작업을 최적화할 수 있음
                    - 렌더링하는 과정에서 특정 값이 바뀌었을 때만 연산을 실행하고, 해당 값이 바뀌지 않았다면 캐시해 놓은 이전 계산 결과를 그대로 재사용하는 방식으로 최적화 수행

                    const cachedValue = useMemo(calculateValue, dependencies)
                        - 첫번째 인수 : 해당 값을 계산하는 함수
                        - 두번째 인수 : 배열을 전달받음. 전달 받은 배열에 포함된 값이 변경되면 첫번째 인수로 전달된 함수를 호출하여 해당 값을 계산하고, 값이 변경되지 않았다면 이전에 연산한 값 그대로 재사용



                useCallback Hook
                    - 이전에 정의해 놓은 함수를 캐시해 놓음으로써, 렌더링 성능 최적화 가능
                    - 리렌더링 간 함수의 정의를 캐시하여 필요한 때 해당 함수를 재생성하는 방식으로 최적화 수행

                    const cachedFn = useCallback(fn, dependencies)
                        - 첫번째 인수 : 생성하고 싶은 함수의 정의
                        - 두번째 인수 : 배열, 이 배열에는 어떤 값이 바뀌었을 때 함수를 새로 생성해야 하는지 명시

-->