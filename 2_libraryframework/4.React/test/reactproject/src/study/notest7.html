<!-- 

    Hook

        Hook?
            - 클래스 컴포넌트를 작성할 필요 없이 함수 컴포넌트에서도 state 관리와 생명주기(lifecycle) 메소드 등 여러 다양한 React 기능 사용 가능
            - state, context, ref, lifecycle 등 다양한 React 개념을 사용자가 손쉽게 사용할 수 있도록 좀 더 직관적인 API(내장 Hook)을 제공함
            - 컴포넌트 사이의 state 관련 로직을 재사용하기 위해 사용자가 직접 자신만의 Hook을 만들어 사용할 수 있음

        Hook 특징
            - 컴포넌트로부터 state 관련 로직을 추상화 할 수 있고 이를 활용하여 독립적인 테스트와 로직의 재사용이 가능해짐
            - state 관련 로직과 사이드 이펙트(side effect) 등이 포함된 복잡한 컴포넌트를 유지보수가 쉬워지도록 비슷한 동작을 하는 컴포넌트들로 나누어 관리 가능
            - 이전 버전의 React(v16.8이전) 과도 호환되므로 클래스 컴포넌트 기반으로 구현된 기존의 React 프로젝트에도 Hook을 점진적으로 도입할 수 있음
        
        Hook 사용 규칙
            - 반복문, 조건문, 중첩된 함수 등에서 호출해서는 안됨
            - 반드시 컴포넌트의 최상위 레벨에서 호출해야 함
            - 일반 자바스크립트 함수에서 호출해서는 안되며 React의 함수 컴포넌트 내에서만 호출해야 함
            - (사용자 정의 Hook 내에서도 Hook을 호출할 수 있음)

        내장 Hooks(built-in hooks)
            - React에서 기본적으로 제공하고 있는 내장 Hook

            1. State Hooks
                - React 컴포넌트는 state를 활용하여 가변적인 상태(state)를 기억할 수 있음
                - 사용자 입력을 저장하기 위해, 현재 카운터를 저장하기 위해 등 사용할 수 있음
                
                - state를 추가하기 위한 Hook
                    - useState : 사용자가 직접 업데이트할 수 있는 state 변수 선언
                    - useReducer : reducer 함수 내부의 업데이트 로직을 사용하여 state 변수를 선언



                    useState Hook
                        - const [state, setState] = useState(initialState)
                        - 처음 렌더링을 수행할 때 초기 상태 값(initialState)을 인수로 전달 받고, 최신 state 값을 유지하는 변수와 그 값을 업데이트할 수 있는 함수 반환

                        ex)

                        import {useState} from "react";

                        const Counter = () => {
                            comst [state, setState] = useState(0);
                            
                            return (
                                <div>
                                    <h1>State 값 : {state}</h1>
                                    <button onClick={() => setState(state + 1)}>1씩 증가</button>
                                </div>
                                );
                            };

                        export default Counter;
                                


                    useReducer Hook
                        - const [state, dispatch] = useReducer(reducer, initialArg, init?)
                        - useState보다 좀 더 복잡한 상황에서 state를 사용할 수 있도록 컴포넌트와 state의 업데이트 로직을 서로 분리시켜 관리 가능
                        - 첫번째 인수 : reducer 함수를 전달 받음
                        - 두번째 인수 : reducer의 기본값 전달 받음
                        - 현재 state 값과 action을 발생시키는 dispatch 함수를 반환함
                        - useReducer가 반환하는 dispatch 함수를 사용하면 state를 다른 값으로 업데이트하고 리렌더링하도록 설정할 수 있음
                        - dispatch 함수에는 인수로 action 값을 전달해야 함
                        - useReducer를 사용했을 때 장점은 컴포넌트에서 state 업데이트 로직을 컴포넌트 외부로 분리시킬 수 있다는 점

                        ex)

                        import { useReducer } from "react";

                        // 컴포넌트와 분리된 state 업데이트 로직
                        const reducer = (state, action) => {
                            if (action.type === "increment") {
                                return {
                                    count: state.count + 1
                                };
                            }
                        };

                        const Counter = () => {
                            const [state, dispatch] = userReducer(reducer, { count: 0 });

                            return (
                                <div>
                                    <h1>State 값 : {state.count}</h1>
                                    // dispatch 함수에 action.type 값으로 'increment'를 전달하여 리렌더링시킴
                                    <button onClick={() => dispatch({ type: "increment "})}>1씩 증가</button>
                                </div>
                            )
                        }


            2. Context Hooks



            3. Ref Hooks
                - const ref = useRef(initialValue)
                - ref를 활용하여 특정 DOM 노드를 선택하거나 컴포넌트 내의 변수를 관리할 수 있도록 해줌
                - 인수로 전달된 값(initialValue)으로 초기화 된 변경 가능한 ref 객체를 반환
                - 이 객체는 컴포넌트의 전 생명 주기동안 유지됨
                - ref 객체는 current라는 프로퍼티 하나만 가지고 있으며, 이 current 값이 실제 엘리먼트를 가리키게 됨
                - useRef를 사용하여 생성한 ref 객체를 JSX 노드의 ref 속성으로 전달하면, React는 전달 받은 ref 객체를 해당 노드의 current 프로퍼티를 설정함. 다음 렌더링 시에도 useRef는 동일한 ref 객체를 반환함
                - ref 속성? (ElementRef?) : https://velog.io/@hyoribogo/react-useref

                ex) 
                    import { useState, useRef } from 'react';
                    import video from "./flower.mp4";

                    const VideoPlay = () => {
                        const [isPlaying, setIsPlaying] = useState(false);
                        const ref = useRef(null);

                        // ref.current로 재생 중이면 pause, 정지 중이면 play로 
                        const handleClick = (0 => {
                            if(isPlaying) {
                                ref.current.pause();
                            } else {
                                ref.current.play();
                            }

                            // not 연산자로 boolean 반대로 만들기
                            setIsPlaying(!isPlaying);
                        };

                        return (
                            <>
                                <video
                                    width="240"
                                    ref={ref}
                                    onPlay={() => setIsPlaying(true)}
                                    onPause={( => setIsPlaying(false))}
                                >
                                <source src={video} type="video/mp4" />
                                <br />
                                <button onClick={handleClick}>{isPlaying ? "Pause" : "Play"}</button>
                            </>

                            export default VideoPlayer;
                        )

                    }




            4. Effect Hooks
                
                사이드 이펙트(side effects)
                    - 일부 React 컴포넌트는 화면에 표시되는 동안 네트워크, 브라우저 API 또는 다른 라이브러리와 연결된 상태를 유지해야 하는 경우가 발생할 수 있음
                    - 이렇게 React에 의해 제어되지 않는 시스템을 외부 시스템(external system)이라고 부름
                    - 대부분 React 컴포넌트는 순수 함수(pure function)처럼 동작하며 동일한 props를 인수로 전달 받으면 언제나 동일한 JSX 노드를 반환함
                    - 반면에 함수 내의 코드가 실행되면서 함수 외부에 존재하는 값이나 상태 등을 변경시킴으로써 다른 곳에서 예기치 못한 결과를 발생시키는 경우도 있을 수 있음
                    - React 에서는 컴포넌트가 화면에 렌더링된 후에 외부 시스템과 연결된 상태에서 비동기적으로 처리되어야 하는 작업들을 사이드 이펙트 또는 이펙트라고 부름
                    - 사이드 이펙트는 외부 시스템과 함께 수행되기 때문에 그 결과를 정확히 예측할 수 없음
                    - 컴포넌트 내에서 사이드 이펙트를 직접 수행하는 것은 컴포넌트 렌더링에 방해가 될 수 있으므로 사이드 이펙트는 렌더링 과정과는 분리되는 것이 좋고 렌더링이 끝난 후
                    처리되는 것이 바람직함
                    - React에서는 특정 데이터를 가져오기 위해 외부 API 등을 호출하는 경우 화면에 렌더링할 수 있는 데이터를 먼저 모두 렌더링 한 후 실제 데이터는 비동기로 가져오는 것을 권장함

                    대표적인 사이드 이펙트 작업
                        - 컴포넌트 DOM 직접 수정
                        - 데이터를 가져오기 위한 외부 API 연동
                        - setTimeout(), setInterval() 등을 사용한 호출 스케줄링

                    useEffect Hook
                        - 컴포넌트 내에서 이러한 사이드 이펙트를 직접 수행하는 것은 컴포넌트 렌더링에 방해될 수 있음
                        - 사이드 이펙트는 렌더링 과정과는 분리되는 것이 좋고 컴포넌트의 렌더링이 끝난 후에 처리되는 것이 좋음
                        - React에서 특정 데이터를 가져오기 위해 외부 API 등을 호출하는 경우 화면에 렌더링할 수 있는 데이터를 먼저 모두 렌더링한 후 실제 데이터는 비동기로 가져오는 것을 권장함
                        - useEffect는 클래스 컴포넌트에서 여러 생명 주기 메소드를 사용하여 복잡한 과정을 통해 처리했던 사이드 이펙트 로직을 하나의 Hook으로 처리할 수 있또록 도와줌
                        - useEffect(setup, dependencies)
                            - setup 함수 : 컴포넌트가 렌더링된 이후에 호출됨. setup 코드를 통해 외부 시스템과 연결하고 시스템과 연결을 종료할 수 있는 cleanup 함수(정리 함수) 반환
                            - dependency array : 종속성 배열, 사이드 이펙트가 의존하는 모든 값을 포함하고 있는 배열. 필요할 때마다 setup, cleanup 함수를 호출하며 여러번 반복 가능
                        - useEffect는 렌더링 될 때마다 기본적으로 실행되지만, 의존성배열과 setup 함수 반환문의 존재 여부에 따라 실행되는 조건이 달라짐

                        컴포넌트가 업데이트 될 때마다 실행
                            - 종속성 배열에 특정 props나 state가 저장되어 있다면, 컴포넌트가 가장 처음 렌더링 될 때 + 해당 값이 변경될 때 setup 함수 실행
                            - 생명 주기 메소드 중 componentDidUpdate 동작과 동일함

                            ex)
                                const [state, setState] = useState("");
                                // 호출 횟수를 체크하기 위한 ref 생성
                                let ref = useRef(0);

                                // state가 업데이트 될 때마다 setup 함수 실행
                                useEffect(() => {
                                    ref.current = ref.current + 1
                                    console.log(`setup 함수 실행 (${ref.current})`); // 1 2 3 4 5 6 7 8 9 10
                                    console.log({state});
                                }, [state]);

                        컴포넌트가 언마운트 되기 직전에만 실행
                            - setup 함수가 cleanup 함수를 반환한다면, 컴포넌트가 언마운드 되기 직전에 해당 cleanup 함수가 실행됨
                            - 생명 주기 메소드 중 componentWillUnmount 동작과 동일함

                            ex)
                                useEffect(() => {
                                    ref.current = ref.current + 1
                                    console.log(`setup 함수 실행 (${ref.current})`); // 1 2 3 4 5 6 7 8 9 10
                                    console.log({state});
                                    return () => {
                                        console.log(`cleanup 함수 실행(${ref.current})`);
                                    };
                                }, [state]);



                        componentDidUpdate, componentWillUnmount(), 마운트, 언마운트
                            - https://ko.legacy.reactjs.org/docs/react-component.html



            5. Performance Hooks
                - 리렌더링 성능을 최적화하는 일반적인 방법은 불필요한 작업을 건너뛰는 것
                - 직전에 렌더링한 이후 데이터가 변경되지 않았다면 캐시된 데이터를 재사용하거나 리렌더링을 건너뛰도록 설정할 수 있음
                - 데이터를 캐시하려면 useMemo나 useCallback을 사용할 수 있음
                - 렌더링 우선 순위를 지정하려면 useTransition이나 useDeleredValue를 사용할 수 있음

                - React에서 데이터를 캐시하려면 다음 Hook 중 하나 사용
                    - useMemo : 이전에 수행한 계산 결과를 캐시하여 재사용할 수 있음
                    - useCallback : 이미 만들어 놓은 함수를 캐시하여 재사용할 수 있음



                useMemo Hook
                    - 이전에 수행한 계산 결과를 캐시해 놓으면, 컴포넌트 내부에서 발생하는 연산 작업을 최적화할 수 있음
                    - 렌더링하는 과정에서 특정 값이 바뀌었을 때만 연산을 실행하고, 해당 값이 바뀌지 않았다면 캐시해 놓은 이전 계산 결과를 그대로 재사용하는 방식으로 최적화 수행

                    const cachedValue = useMemo(calculateValue, dependencies)
                        - 첫번째 인수 : 해당 값을 계산하는 함수
                        - 두번째 인수 : 배열을 전달받음. 전달 받은 배열에 포함된 값이 변경되면 첫번째 인수로 전달된 함수를 호출하여 해당 값을 계산하고, 값이 변경되지 않았다면 이전에 연산한 값 그대로 재사용

                        ex)

                        



                useCallback Hook
                    - 이전에 정의해 놓은 함수를 캐시해 놓음으로써, 렌더링 성능 최적화 가능
                    - 리렌더링 간 함수의 정의를 캐시하여 필요한 때 해당 함수를 재생성하는 방식으로 최적화 수행

                    const cachedFn = useCallback(fn, dependencies)
                        - 첫번째 인수 : 생성하고 싶은 함수의 정의
                        - 두번째 인수 : 배열, 이 배열에는 어떤 값이 바뀌었을 때 함수를 새로 생성해야 하는지 명시

                        ex)



-->