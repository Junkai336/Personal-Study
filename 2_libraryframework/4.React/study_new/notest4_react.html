<!-- 
컴포넌트
  - html 태그를 반환(return)하는 함수

함수 컴포넌트
  - 함수로 만든 컴포넌트
  - 선언적 함수, 익명 함수 둘 다.
  - 컴포넌트를 생성하는 함수는 첫글자 대문자

  - <컴포넌트 /> : 컴포넌트의 반환 값을 불러와서 렌더링 시킴
  - 자식 컴포넌트 : 다른 컴포넌트의 리턴문 내부에 포함되는 컴포넌트
  - 부모 컴포넌트 : 다른 컴포넌트를 리턴문 내부에 포함하고 있는 컴포넌트 

  - 리액트의 모든 컴포넌트들은 화면에 렌더링 되기 위해서 App 컴포넌트(최상위 조상)(루트 컴포넌트)의 자식 컴포넌트로서 존재해야 함

JSX
  - 자바스크립트 코드 안에 HTML 태그를 삽입하고 리턴할 수 있게 해 줌
  - 확장된 자바스크립트 문법

  - JavaScript Extensions
  - JavaScript + HTML

  - 컴포넌트 내부에 변수를 선언한 후 선언한 값을 중괄호 {} 로 넣어서 HTML로 렌더링하도록 설정할 수 있음
  - 숫자나 문자열로 표현될 수 있는 값이라면 무엇이든지 넣어줄 수 있음 (삼항연산자, 조건부표현식, 배열 등)

    - 주의 사항
      - 중괄호 내부에는 자바스크립트 표현식만 넣을 수 있다. (값으로  평가되는 식) (for문 x if문 x)
      - 객체 같은 경우는 에러를 내뿜으므로, 객체.프로퍼티로 문자열이나 숫자값을 렌더링해야 함
      - 모든 태그는 닫혀 있어야 한다.
      - 최상위 태그는 반드시 하나여야만 한다.

    - 스타일
      - 인라인CSS : 카멜 케이스, 객체로 전달
        - <div style={ {backgroundColor: "red", borderBottom: "5px solid blue"} }>

      - 외부CSS : import "~.css"

  function Footer() {
    const myName = 'a'

    return (
      <footer>
        <h1>내 이름은 {myName}</h1>
      </footer>
    )
  }

Props
  - 컴포넌트에 전달된 값들
  - 리액트 컴포넌트에게 값을 넘겨주는 방법
  - 부모 컴포넌트가 자식 컴포넌트들에게 마치 함수의 인수를 전달하듯이 원하는 값을 전달해 주는게 가능
  - props를 활용하면 컴포넌트에 전달하는 값에 따라서 다른 UI를 렌더링할 수 있도록 함

  - defaultProps : 컴포넌트가 특정 props를 전달받지 않았을 때 사용할 기본값 정의
  - Mycomponent.defaultProps = { name : "Guest" }

  - 일반적인 문자열같은 JS 값 뿐만 아니라 HTML 요소나 React 컴포넌트도 전달할 수 있음
  - 컴포넌트의 자식요소들은 자동으로 children props로 전달됨

  - 부모 컴포넌트로부터 자식 컴포넌트로만 전달할 수 있음 (= 데이터들은 항상 위에서 아래로 하나의 방향으로만 흐르게 됨) (단방향 데이터 흐름)

  function App() {
    return (
      <Button text = {"메일"} img={"mail.png"} />     <- 자식 컴포넌트
      <Button text = {"카페" img={"cafe.png"} />
      <Button text = {"블로그"} img={"blog.png"} />
    )
  }

이벤트 핸들링
  - 이벤트 : 웹 내부에서 발생하는 사용자의 행동 (버튼 클릭, 메시지 입력, 스크롤 등)
  - 웹에서 이벤트가 발생했을 때 처리하는 것 (ex: 버튼 클릭시 경고창 노출) (onClick = {() => {}})

  - 이벤트 객체
    - 모든 이벤트는 이벤트 핸들러 함수를 호출하면서 호출된 매개 변수로 event 객체를 제공함
    - 콘솔에 출력해 보면 이벤트에 관한 다양한 정보가 나옴
    
    - SyntheticBaseEvent : 이벤트 매개변수에 저장된 이벤트 객체, 합성 이벤트 객체, 모든 브라우저에서 사용할 수 있는 통합된 규격의 이벤트 객체
      - 합성 이벤트 : 모든 웹 브라우저의 이벤트 객체를 하나로 통일한 형태, 
                      여러 브라우저들의 규격을 참고해서 하나의 통일된 규격으로 이벤트 객체를 포멧팅 함
                      크로스 브라우저 이슈를 편리하게 해결할 수 있음
      - cross browsing issue : 브라우저 별 스펙이 달라 발생하는 문제

    - event.target : 이벤트가 발생한 DOM 요소 참조
    - event.currentTarget : 이벤트 핸들러가 등록된 DOM 요소 참조
    - event.type : 발생한 이벤트의 타입을 문자열로 반환
    - event.preventDefault() : 기본 동작 방지
    - event.stopPropagation() : 이벤트 전파 중단

    - event.persist() : 이벤트 핸들러가 호출된 이후에도 이벤트 객체를 재활용하는데, 비동기 작업에서 이벤트 객체를 사용하려면 이벤트 속성을
                        미리 복사하거나 이 메소드로 해당 객체가 풀링되지 않도록 해야 함

State
  - 상태
  - 컴포넌트의 현재 상태를 보관하고 있는 변수
  - State를 갖는 React 컴포넌트는 State의 값에 따라 렌더링되는 UI가 결정된다.
  - 컴포넌트의 State의 값이 바뀐 걸 감지하면 자동으로 이 컴포넌트를 다시 렌더링시켜 주게 됨
  - 리렌더링 : 컴포넌트가 다시 렌더링되는 상황
  - useState
    - console로 출력해보면 배열의 [0] : state의 값, [1] : 상태변화함수
    - 그러므로 구조분해할당으로 [state, setState] = useState(''); 로 분배함
  - 리액트 컴포넌트는 일반적인 변수가 아니라 state의 값이 변화했을 때에만 리렌더링이 됨
  - 변화하는 가변적인 값을 관리할 때 화면에 렌더링 시켜주고 싶을 때 state를 사용하여 처리해야 한다.
  - 스테이트 리프팅: 하나의 state를 여러 컴포넌트에서 관리할 경우 이 state는 반드시 컴포넌트들의 공통 부모가 되는 곳에 만들어야 됨

리렌더링의 조건
  - 자신이 관리하는 state 값이 변경될 때
  - 자신이 제공받는 props 값이 변경될 때
  - 부모 컴포넌트가 리렌더링되면 자식 컴포넌트도 리렌더링 된다.

useRef
  - 새로운 Reference 객체를 생성하는 기능
  - 컴포넌트 내부의 변수로써 일반적인 값들을 저장할 수 있음
  - 어떤 경우에도 리렌더링을 유발하지 않음
  - 렌더링에 영향을 미치고 싶지 않은 변수를 생성할 때 이용하게 됨
  - useRef를 이용하면, 컴포넌트가 렌더링하는 특정 DOM 요소에 접근할 수 있고 해당 요소를 조작하는 것도 가능함
    (특정 요소의 스타일을 갑자기 바꿀 수도 있다.)
  - current라는 프로퍼티에 현재 보관할 값을 담아두기만 하는 단순한 js 객체
  - ref 객체의 값을 사용하고 싶다면, 객체.current 로 읽어줄 수 있음
  - ref 속성 : <input ref={refObj}/> 등과 같이 DOM 요소에 접근 가능
  - JSX에서 ref라는 속성 이름을 사용하면, 렌더링 후 해당 DOM 또는 컴포넌트를 refObj.current에 할당해 줌
  - 일반 js 변수로 선언해서 dom 요소에 접근하더라도 state가 있다면, 리렌더링되면서 처음값으로 초기화됨 
    (0인 변수++ 하더라도 리렌더링되면서 함수가 다시 실행되면서 계속 0으로 초기화되는 거임)
  - 일단 기본적으로 state 변경으로 리렌더링이 되더라도 리렌더링으로 인한 자동 초기화는 일어나지 않음
    (useRef의 반환값은 컴포넌트가 마운트될 때 한 번 생성되고, 언마운트될 때까지 계속 유지되기 때문)

    - 객체 ref
      - 하나의 DOM 요소만 추적할 때 심플하게 사용 가능

        const myRef = useRef(null);
        <input ref={myRef} />

    - 콜백 ref
      - ref를 설정할 때 문자열이나 객체를 넘기는 대신, 함수를 ref로 전달하는 방식
      - React는 해당 ref가 연결될 때마다(마운트 시점) 콜백 함수를 호출하고, 언마운트 시점에는 null을 인자로 다시 호출해줌
      - React가 요소를 마운트하거나 업데이트할 때 ref에 전달된 콜백 함수를 호출하는데 함수의 인자로 해당 요소의 실제 DOM 노드 또는 컴포넌트
        인스턴스가 전달됨
      - 인자를 원하는 곳에 직접 저장하거나, 추가적으로 다른 로직 수행 가능
      - <textarea ref={(el) => { ... }}
      - 사용이유
        - useRef()를 여러 번 선언하기보다, 하나의 객체에 필요한 DOM 래퍼런스를 모두 저장하고 싶을 때 유용

        function MyComponent() {
          const inputRefs = useRef({});

          return (
            <div>
              <input
                type = "text"
                name = "name"
                ref = {(el) => { inputRefs.current.name = el; }}
              />

              <textarea
                name = "bio"
                ref = {(el) => { inputRefs.current.bio = el; }}
              />

            </div>
          )
        }
        
        - el : DOM 노드 (<input>의 실제 DOM 객체), 원하는 객체나 변수에 저장할 수 있음
        - 추후에 inputRefs.current.name.focus() 처럼 직접 DOM 메소드 호출 가능

    - 차이
      - 객체 ref : React가 DOM 노드를 생성할 때 const ref = useRef(null); ref에 자동으로 참조를 넣어줌

      - 콜백 ref : 함수를 통해 el을 전달받고, 어떤 동작을 할 지 개발자가 직접 제어 가능
                    한 번의 렌더링마다 이 콜백이 불리므로, DOM 참조 외에 다른 로직도 실행 가능
                    여러 DOM을 한 객체 안에 저장하기 쉬움

React Hooks
  - 클래스 컴포넌트의 기능을 함수 컴포넌트에서도 이용할 수 있도록 도와주는 메소드들
  - 문법이 복잡한 클래스 컴포넌트의 기능을 마치 낚아채듯이 가져와서 사용할 수 있게 해주는 기능
  - useState, useRef, useEffect, useReducer, +약 20개...
  - 이름 앞에 use라는 접두사가 붙음
  - 함수 컴포넌트 내부에서만 호출 가능, 조건문 반복문 내부에서는 호출 불가

라이프 사이클
  - LifeCycle, 생애 주기
  - 탄생부터 죽음까지의 타임라인을 단계별로 나누어 놓은 것
  - Mount , Update , UnMount 라는 세 단계로 구분

  - Mount : 컴포넌트가 탄생하는 순간, 화면에 처음 렌더링 되는 그 순간 , Mount 되었다 = 컴포넌트가 화면에 처음으로 렌더링 되었다.
          (ex: 컴포넌트가 화면에 처음 나타났을 때, 백엔드 서버에 네트워크 요청을 보내서 데이터를 불러오는 기능)
          
  - Update : 컴포넌트가 다시 렌더링되는 순간 , 리렌더링 될 때를 의미 , Update 되었다 = 컴포넌트가 리렌더링 되었다.
          (ex: 변경된 값이 무엇인지 콘솔에 출력)
          
  - UnMount : 컴포넌트가 화면에서 사라지는 순간 , 렌더링에서 제외되는 순간 , UnMount 되었다 = 컴포넌트가 화면에서 사라졌다. 
          (ex: 컴포넌트가 사용하던 메모리 정리)

  - 라이프 사이클 제어 : 라이프 사이클 단계별로 컴포넌트들이 각각 다른 작업을 수행하도록 만드는 것

useEffect
  - 컴포넌트의 사이드 이펙트를 제어하는 리액트 훅
  - 사이드 이펙트 : 부수적인 효과, 컴포넌트의 동작에 따라 파생되는 효과
  - 컴포넌트 내부값 변경, Mount, Update, UnMount 등이 되었을 때 특정 코드를 실행시킬 수 있다.
  - useEffect(() => {}, [])
  - 의존성 배열의 값이 변경되면 첫번째 인수로 전달한 콜백함수를 실행시켜준다.
  - useEffect(() => {}, []) : 의존성 배열이 빈 배열일 때에는 콜백함수가 마운트 될 때에만 1번만 실행
  - useEffect(() => {}) : 마운트 될 때 1번 실행 뒤 리렌더링 될 때마다 계속 실행됨
  
  - 리렌더링 될 때에만 실행시키고 싶은 경우
  ex)
    const isMount = useRef(false);

    useEffect(() => {
      if(!isMount.current) {
        isMount.current = true;
        return;
      }
      ~~~
    })

  - 언마운트 예시
  - useEffect의 return문은 언마운트될 때 한 번 실행된다.
  - 컴포넌트가 DOM에서 사라질 때, 정리 코드를 수행
  - 의존성 배열이 빈 경우 언마운트시 + 업데이트시 cleanup이 실행됨

  ---------

  ex)
    useEffect(() => {
      // effect 로직 (컴포넌트 마운트 완료 후 실행할 로직)
      
      return () => {
        // cleanup 로직 (컴포넌트 언마운트 직전 정리 로직)
        // clearInterval, removeEventListener 등으로 외부 자원을 정리하거나 필요한 후처리를 함

      };        
    }, [])

    (1) 마운트 후 useEffect 본문 실행
    (2) 업데이트 변경 발생시 추가 실행 없음 (의존성 배열 [])
    (3) 언마운트시 useEffect의 cleanup 함수 return문 실행

  --------

    ex)
    useEffect(() => {
    
    return () => {
    }

    }. [값])

    (1) 마운트 후 useEffect 본문 실행
    (2) 의존성 값 변경 시 이전 이펙트의 cleanup 실행
    (3) 새 렌더링 후 다시 이펙트 본문 실행
    (4) 언마운트시 cleanup 실행

  --------

  ex)
    useEffect(() => {
    
    return () => {
    }

    })

  (1) 마운트 > useEffect 본문 실행
  (2) 상태/props 변경으로 재렌더링 준비
  (3) 이전 useEffect의 cleanup 실행
  (4) 새 렌더링 완료 후 useEffect 본문 재실행
  (5) 상태/props 변경...
  (6) cleanup...
  (7) 재실행...
  ... (반복) ...
  마지막으로 언마운트 시 cleanup 실행



React 개발자 도구
  - 크롬 웹스토어 React Developer Tools
  - 컴포넌트, props, state 등 확인할 수 있음.
  - 개발자도구 들어가서 우측 상단 >> 클릭
  - 리렌더링시 컴포넌트 하이라이트 가능

-->