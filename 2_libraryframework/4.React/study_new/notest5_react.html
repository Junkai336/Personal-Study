<!-- 
useReducer
  - 컴포넌트 내부에 새로운 State를 생성하는 React Hook
  - 모든 useState는 useReducer로 대체 가능
  - useState로 관리하기엔 상태가 많아져 코드가 지저분해지거나, 상태 업데이트 로직이 여러 조건과 단계를 거치는 경우 사용
  - useState와의 차이점
    - 상태 관리 코드를 컴포넌트 외부로 분리할 수 있음
    - 컴포넌트 내부에서 state 생성만 해놓고 state를 관리하는 코드들은 reducer라는 함수로 컴포넌트 외부에서 관리하도록 코드를 분리할 수 있음

  - const [state, dispatch] = useReducer(reducer, initialState);
    - reducer : 상태를 업데이트하는 함수 (state, action) => newState 형태로 정의됨
    - initialState : 상태의 초기값
    - state : 현재 상태
    - dispatch : 액션을 발생시키는 함수, 액션은 상태를 업데이트하는 데 필요한 정보 포함

최적화
  - 웹 서비스의 성능을 개선하는 모든 다양한 행위
    - 서버의 응답속도 개선
    - 이미지, 폰트, 코드 파일 등의 정적 파일 로딩 개선
    - 불필요한 네트워크 요청 줄임
    - 기능구현을 하고 최적화를 하는게 일반적
    - 최적화에도 필요한 연산이 있기 때문에 너무 단순한 컴포넌트는 최적화를 해도 성능이 비슷할 수 있다.
    - 유저의 행동에 따라서 개수가 굉장히 많아질 수 있는 컴포넌트나 함수들을 많이 가지고 있어서 코드가 무거운 컴포넌트 등이 대상
      (최적화가 꼭 필요할 것들에만 제한하는 걸 추천)

  - React App 내부 최적화 방법
    - 컴포넌트 내부의 불필요한 연산 방지
    - 컴포넌트 내부의 불필요한 함수 재생성 방지
    - 컴포넌트의 불필요한 리렌더링 방지

useMemo
  - 컴포넌트의 불필요한 연산 방지
  - 메모이제이션 기법을 기반으로 불필요한 연산을 최적화하는 리액트 훅
  - 메모이제이션 : 기억해두기, 메모해두기
  - 반복적으로 수행되는 동일한 연산이 있을 때 매번 결과값을 새롭게 다시 계산하도록 만드는 게 아니라 
    최초로 한번 계산 했을 때의 결과값을 메모리 어딘가에 보관해둔 다음 다시 이 연산이 필요해지면
    저장되어 있던 결과값을 바로 돌려주는 기법

React.memo
  - 컴포넌트의 불필요한 리렌더링 방지
  - 리액트 내장 메소드
  - 컴포넌트를 인수로 받아 최적화된 컴포넌트로 만들어 반환
  - const MemoizedComponent = memo(Component)
  - 부모 컴포넌트로부터 리렌더링 되더라도 자신이 받는 props가 바뀌지 않으면 다시는 리렌더링이 발생하지 않도록 메모이제이션 됨

고차 함수 컴포넌트
  - 컴포넌트를 인수로 받아서 해당 컴포넌트에 최적화나 메모이제이션 같은 추가적인 기능을 덧붙여서 
    기능이 추가된 새로운 컴포넌트를 반환해주는 memo와 같은 메소드들을 고차 함수 컴포넌트라고 부름

useCallback
  - 불필요한 함수 재생성 방지
  - 함수 컴포넌트를 렌더링할 때 특정 함수를 재생성하지 않고 이전에 생성한 함수를 재사용하도록 도와줌
  - 자식 컴포넌트에 함수를 props로 전달할 경우 불필요한 리렌더링이 발생할 수 있는데, useCallback을 사용하면 의존성 배열에 담긴 값이 변화할 때만 함수 렌더링
  - 함수가 가볍거나 재생성 비용이 크지 않으면 생략해도 ㄱㅊ
  - 의존성배열 [] 안에 지정된 값이 변경되었을 때만 함수가 새로 생성됨
  - const func = useCallback(() => {}, []);



Context
  - 컴포넌트간의 데이터를 전달하는 또 다른 방법
  - 기존의 Props가 가지고 있던 단점을 해결할 수 있음
  - Props 단점
    - 부모 -> 자식으로만 데이터를 전달할 수 있음
    - 부모 -> 자식 -> 자식 구조면 한단계씩 아래로 props를 전달해야 해서 Props Drilling이 발생함
  - Context (데이터 보관소 객체) 를 생성하고 원래 자식 컴포넌트에게 전달되던 props들을 컨텍스트에다가 보관해 놓고
    다이렉트로 컨텍스트를 통해서 필요한 데이터를 공급해 줄 수 있음
    컨텍스트를 여러개 만드는 것도 가능
  - useContext() : 인수로 전달한 context로부터 공급된 데이터를 반환해주는 함수

-->