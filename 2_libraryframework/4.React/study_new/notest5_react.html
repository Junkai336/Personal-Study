<!-- 
useReducer
  - 컴포넌트 내부에 새로운 State를 생성하는 React Hook
  - 모든 useState는 useReducer로 대체 가능
  - useState로 관리하기엔 상태가 많아져 코드가 지저분해지거나, 상태 업데이트 로직이 여러 조건과 단계를 거치는 경우 사용
  - useState와의 차이점
    - 상태 관리 코드를 컴포넌트 외부로 분리할 수 있음
    - 컴포넌트 내부에서 state 생성만 해놓고 state를 관리하는 코드들은 reducer라는 함수로 컴포넌트 외부에서 관리하도록 코드를 분리할 수 있음

  - const [state, dispatch] = useReducer(reducer, initialState);
    - reducer : 상태를 업데이트하는 함수 (state, action) => newState 형태로 정의됨
    - initialState : 상태의 초기값
    - state : 현재 상태
    - dispatch : 액션을 발생시키는 함수, 액션은 상태를 업데이트하는 데 필요한 정보 포함

최적화
  - 웹 서비스의 성능을 개선하는 모든 다양한 행위
    - 서버의 응답속도 개선
    - 이미지, 폰트, 코드 파일 등의 정적 파일 로딩 개선
    - 불필요한 네트워크 요청 줄임
    - 기능구현을 하고 최적화를 하는게 일반적
    - 최적화에도 필요한 연산이 있기 때문에 너무 단순한 컴포넌트는 최적화를 해도 성능이 비슷할 수 있다.
    - 유저의 행동에 따라서 개수가 굉장히 많아질 수 있는 컴포넌트나 함수들을 많이 가지고 있어서 코드가 무거운 컴포넌트 등이 대상
      (최적화가 꼭 필요할 것들에만 제한하는 걸 추천)

  - React App 내부 최적화 방법
    - 컴포넌트 내부의 불필요한 연산 방지
    - 컴포넌트 내부의 불필요한 함수 재생성 방지
    - 컴포넌트의 불필요한 리렌더링 방지

useMemo
  - 컴포넌트의 불필요한 연산 방지
  - 메모이제이션 기법을 기반으로 불필요한 연산을 최적화하는 리액트 훅
  - 메모이제이션 : 기억해두기, 메모해두기
  - 반복적으로 수행되는 동일한 연산이 있을 때 매번 결과값을 새롭게 다시 계산하도록 만드는 게 아니라 
    최초로 한번 계산 했을 때의 결과값을 메모리 어딘가에 보관해둔 다음 다시 이 연산이 필요해지면
    저장되어 있던 결과값을 바로 돌려주는 기법

  - 재연산을 방지 = 해당 값을 만드는 연산이 매 렌더링마다 다시 수행되는 것을 막는다.
  - 비싼 연산의 결과나 객체/배열을 메모이징 할 때 사용
  - 의존성 배열이 바뀌지 않는 한, 기존 결과를 재사용

    const bigArray = [엄청난 데이터들]
    const expensiveResult = useMemo(() => {
      ...
      return bigArray.filter()..sort()...;
    }, [bigArray]);

React.memo
  - 컴포넌트의 불필요한 리렌더링 방지
  - 리액트 내장 메소드
  - 컴포넌트를 인수로 받아 최적화된 컴포넌트로 만들어 반환
  - const MemoizedComponent = memo(Component)
  - 부모 컴포넌트로부터 리렌더링 되더라도 자신이 받는 props가 바뀌지 않으면 다시는 리렌더링이 발생하지 않도록 메모이제이션 됨

고차 함수 컴포넌트
  - 컴포넌트를 인수로 받아서 해당 컴포넌트에 최적화나 메모이제이션 같은 추가적인 기능을 덧붙여서 
    기능이 추가된 새로운 컴포넌트를 반환해주는 memo와 같은 메소드들을 고차 함수 컴포넌트라고 부름

useCallback
  - 불필요한 함수 재생성 방지
  - 함수 컴포넌트를 렌더링할 때 특정 함수를 재생성하지 않고 이전에 생성한 함수를 재사용하도록 도와줌
  - 자식 컴포넌트에 함수를 props로 전달할 경우 불필요한 리렌더링이 발생할 수 있는데, useCallback을 사용하면 의존성 배열에 담긴 값이 변화할 때만 함수 렌더링
  - 함수가 가볍거나 재생성 비용이 크지 않으면 생략해도 ㄱㅊ
  - 의존성배열 [] 안에 지정된 값이 변경되었을 때만 함수가 새로 생성됨
  - const func = useCallback(() => {}, []);

  - 함수를 메모이징, 의존성 배열이 바뀌지 않으면 기존 함수 참조를 재사용
  - useMemo는 값(연산 결과) 그 자체를 메모하고 리턴값은 메모된 값
  - useCallback은 함수 그 자체를 메모하고 리턴값은 메모된 함수

Context
  - 컴포넌트간의 데이터를 전달하는 또 다른 방법
  - 기존의 Props가 가지고 있던 단점을 해결할 수 있음
  - Props 단점
    - 부모 -> 자식으로만 데이터를 전달할 수 있음
    - 부모 -> 자식 -> 자식 구조면 한단계씩 아래로 props를 전달해야 해서 Props Drilling이 발생함
  - Context (데이터 보관소 객체) 를 생성하고 원래 자식 컴포넌트에게 전달되던 props들을 컨텍스트에다가 보관해 놓고
    다이렉트로 컨텍스트를 통해서 필요한 데이터를 공급해 줄 수 있음
    컨텍스트를 여러개 만드는 것도 가능
  - useContext() : 인수로 전달한 context로부터 공급된 데이터를 반환해주는 함수

페이지 라우팅
  - 경로에 따라 알맞은 페이지를 렌더링하는 과정
  - ex) /new -> new 페이지 렌더링
  - 특정 페이지에 접속하려고 웹서버에게 주소를 요청을 보냈을 때 웹서버가 요청에 따라서 브라우저에게 페이지를 반환해주고
    브라우저는 반환된 페이지를 사용자가 볼 수 있도록 렌더링하는 모든 과정
  - MPA
    - Multi Page Application
    - 서버가 사용자들에게 제공할 여러 개의 페이지를 미리 가지고 있는 방식
    - 많은 서비스가 사용하는 전통적인 방식
    - 단점
      - 새로운 페이지 이동시 공통으로 사용하는 요소가 있더라도 전부 제거하고 새로운 HTML 파일로 페이지를 처음부터 다시 다 그려냄
      - 모든 사용자가 페이지를 이동할 때마다 일일이 서버에게 새로운 페이지에 대한 요청을 보내게 됨. 서버의 부하가 심해짐

  - SSR
    - Server Side Rendering
    - MPA 방식에서 브라우저가 새로운 페이지를 요청했을 때 서버측에서 미리 완성해놓은 HTML 파일을 보내주고 브라우저가 그대로 렌더링하는 방식
    - 서버사이드 렌더링

  - SPA
    - Single Page Application
    - 기본적인 틀 역할을 하는 페이지를 딱 한 개만 가지고 있음
    
    - 어떤 페이지로 접속했든간에 접속 요청이 들어오면, 기본 틀인 index.html 파일을 먼저 보내고 모든 JS 파일을 번들링해서 브라우저에게 후속으로 전달
      브라우저에서는 JS파일을 직접 실행해서 파일에 작성된 컴포넌트들을 직접 화면에 렌더링하게 되면서 페이지가 실제로 렌더링됨
      이때 번들링된 JS파일에는 리액트 문법으로 작성한 모든 정보들이 담겨있기 때문에 결국 이 파일을 리액트 앱이라고 부를 수 있음

    - 링크를 선택해서 새로운 페이지로 페이지 이동이 발생하게 될 경우 새로운 페이지를 매번 서버에 요청하는 MPA 방식과 달리 아무 요청도 보내지 않음
      처음 접속했을 때 서버로부터 받았던 React App을 통해 브라우저 내에서 새로운 페이지에 필요한 컴포넌트들로 화면을 교체함
      그러므로, 아무런 요청도 없이 브라우저가 스스로 페이지를 이동시키는 것
      (리액트 앱에는 모든 페이지, 컴포넌트 정보가 다 포함되어 있기 때문)

    - MPA의 경우 원본을 전부 다 제거하고 새롭게 렌더링 하기 때문에 새로고침이 발생하게 되는데, 
      SPA는 페이지 이동 시 공통 컴포넌트는 냅두고 꼭 필요한 컴포넌트만 교체함
    
    - 다수의 사용자가 몰리더라도 서버의 부하가 심해지지 않는 방식으로 동작 (렌더링을 클라이언트 측인 브라우저에서 담당)
    
    - 화면에 렌더링되어야 하는 요소를 HTML에 직접 작성하지 않고, JS에 컴포넌트로 작성
    
    - 번들링(Bundling)
      - 묶다, 번들된 파일은 번들 파일
      - 리액트 컴포넌트들이나 기능들이 작성되어 있는 모든 JS파일을 하나로 묶어주는 과정 (VITE가 담당)
      - 리액트에서는 번들링된 JS파일을 브라우저에 전달함
    
    - 브라우저는 전달된 번들 파일을 직접 실행. main.jsx의 render메소드로 app 컴포넌트를 화면에 실제로 렌더링함
    
    - 최종적으로 작성한 모든 컴포넌트들이 화면에 렌더링이 되는 것


  - CSR
    - Client Side Rendering
    - 브라우저에서 직접 JS 파일을 실행해서 화면을 직접 렌더링하도록 하는 방식
    - 클라이언트 측인 브라우저에서 직접 렌더링을 실행

페이지 라우팅 설정
  - React Router
    - npmjs.com에 등록되어 있는 라이브러리
    - 대다수 리액트 앱이 사용하고 있는 라이브러리
    - 제공하고 있는 기능
      - Client Side Routing, Nested Routing, Dynamic Segments, Ranked Route Matching, Active Links, Relative Links, Data Loading,
        Redirects, Pending Navigation UI, Skeleton UI With <Suspense>, Data Mutation ...
    - npm i react-router-dom
    
    - <BrowserRouter>
      - 애플리케이션 전체를 감싸면 라우팅 관련 기능인 <Routes>, <Route>, <Link> 사용 가능
      - 브라우저 주소(URL) 변경시 페이지 전체 새로고침 없이 애플리케이션 상태를 유지하며 컴포넌트만 갱신 가능

    - <Routes>
      - <Routes>안에 여러 <Route>를 정의하고 현재 URL 경로에 맞는 <Route>를 렌더링
      - 가장 구체적으로 일치하는 경로를 렌더링함 (switch case문과 비슷)
      - <Routes>안에 div 같은거 넣으면 오류 발생, <Route>만 들어갈 수 있다.
      - <Routes> 외부에 있는 요소들은 라우팅과 관련없이 모든 페이지에 동일하게 렌더링됨

    - <Route>
      - 경로(path), 렌더링할 컴포넌트(element) 매핑 컴포넌트
      - path : props로 URL 경로를 지정
      - element : props로 해당 경로로 접근했을 때 렌더링할 컴포넌트 지정
      - <Routes> 내부에서 사용되고 path와 현재 브라우저 경로가 일치하면 해당 element를 렌더링함
      - * : 와일드카드, 정의한 다른 모든 경로와 매칭되지 않는 경우 이 라우트를 선택하게 됨 (404 페이지 역할)

    - <Link>
      - a태그를 대체하는 기능을 하는 컴포넌트
      - 클라이언트 사이드 렌더링 방식으로 페이지를 이동시킴 (필요한 컴포넌트만 교체)

    - useNavigate
      - 페이지를 실제로 이동시키는 navigate 함수를 반환
      - 클라이언트 사이드 렌더링 방식으로 페이지를 이동시킴
      - 이벤트 핸들러 함수 안에서 특정 조건에 따라서 페이지를 이동시켜야 할 때 사용

동적 경로
    - 동적인 데이터를 포함하고 있는 경로
    - ~/prd/1, ~/prd/2, ~/prd/3 : n번 상품 조회
      
    - URL Parameter
      - / 뒤에 아이템의 id를 명시
      - ~/product/1
      - 아이템의 id 등의 변경되지 않는 값을 주소로 명시하기 위해 사용됨
      - useParams 훅을 사용하여 URL Parameter 값을 가져올 수 있음
      - /users/:parameter 형태로 정의
        - :parameter : 실제 요청시 숫자나 문자열과 같은 구체적인 값으로 대체

        import { Routes, Route } from "react-router-dom";

        function App() {
          return (
            <Routes>
              <Route path='/users/:userId' element={<UserPage />} />
            </Routes>
          );
        }

        function UserPage() {
            const { userId } = useParams();       // URL에서 userId를 추출
            return <div>user Id : {userId}</div>
        }

    - Query String
      - URL의 ? 다음에 키-값 쌍의 형태로 데이터를 전달하는 방식
      - 주로 검색 필터, 페이징, 정렬 옵션 등을 전달하는 데 사용
      - 검색어 등의 자주 변경되는 값을 주소로 명시하기 위해 사용됨
      - ~/route?key1=value1&key2=value2
      - useSearchParams 훅을 사용하여 Query String 값을 가져오거나 설정할 수 있음 

        경로에 /?value=hello 로 들어왔을 경우

        function SearchPage() {
          const [searchParams] = useSearchParams();
          const query = searchParams.get('value');
        
          return (
            <div>{query}</div>
          )

        }

etc
  - vite가 내부적으로 진행하는 이미지 최적화 설정
  
  - public 폴더 안에 있는 이미지들은 import를 통해서 불러오진 않지만 URL을 통해서 불러오도록 설정할 수 있음
  - public 폴더 안 이미지를 경로를 통해서 불러오도록 설정해주면 vite가 자동으로 제공하는 이미지 최적화가 동작하지 않음
  - <img src={"/emotion1.png"} />
  
  - assets 폴더 안에 있는 이미지들은 import를 통해서 불러옴
  - import emotion1 from './assets/emotion1.png';
  - <img src={emotion1}; />

  - 최적화? : 프로덕션 모드로 실행시켜보면 (npm run build) -> 왼쪽 파일 탐색기 dist 폴더 안에 빌드 결과가 있음 -> npm run preview로 실행
              -> 로컬호스트 4173으로 빌드된 결과물에 접속 가능 -> 개발자모드로 확인해보면 assets 폴더 안에서 설정한 이미지들은 Data URI 로 저장됨
  - Data URI : 이미지 같은 외부 데이터들을 문자열 형태로 브라우저의 메모리에 캐싱하기 위해 사용되는 포맷



  
-->