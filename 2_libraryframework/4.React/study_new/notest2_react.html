<!-- 
자바스크립트 심화

  Truthy & Falsy
    - 참이나 거짓을 의미하지 않는 값도 조건문 내에서 참이나 거짓으로 평가하는 특징

    - Falsy한 값
      - undefined
      - null
      - 0
      - -0
      - NaN
      - ""
      - 0n      // Big Integer

    - Truthy한 값
      - Falsy한 값 외에 전부
      - [], {}, () => {}; 다 truthy함

    - 활용

      function printName(person) {
        if(!person) return;                 // person === undefined || person === null

        console.log("person.name");
      }

      let person = null;
      printName(person)





  단락 평가(Short-circuit Evaluation)
    - 첫번째 피연산자의 값이 확정되었을 때 두번째 피연산자의 값에 접근조차 하지 않는 것
    - 조건문을 이용하지 않고도 특정 상황에서 어떠한 함수를 호출하지 않도록 방지하거나 어떠한 값들을 굳이 계산하지 않도록 제한하는 등 할 수 있음
    - 논리 연산식에서 첫번째 피연산자의 값만으로도 연산의 결과를 확정할 수 있다면 두 번째 피연산자에는 접근조차 하지 않는 실행 방식
    - true, false 뿐만 아니라 truthly, falshy한 값도 적용됨

    function returnFalse() {
      console.log("False 함수");
      return false;
    }

    function returnTrue() {
      console.log("True 함수");
      return true;
    }

    console.log(returnFalse() && returnTrue());     // False 함수 , false 만 출력된다.

    console.log(returnTrue() && returnFalse());     // True 함수, False 함수 둘 다 호출되고 false 가 출력된다.

    console.log(returnTrue() || returnFalse());     // True 함수 , true 만 출력된다.

    예시

    let name = null
    let defaultName = "Anoymous";

    let displayName = name || defaultName;  // name이 falshy한 값이라 defaultName이 됨. 반대로 name이 있으면 name이 됨

    예시2

    function printName(person) {
      if(!person) {
        console.log("person에 값이 없음");
        return;
      }

      console.log(person.name);
    }

    대신에

    function printName(person) {
      console.log(person && person.name);
    }

    function printName(person) {
      const name = person && person.name;
      console.log (name || "person의 값이 없습니다.");
    }

    - Truthy한 값 || Truthy한 값 일 경우에 첫 번째 Truthy한 값만 반환됨
    - Truthy한 값 && Truthy한 값 일 경우에 두 번째 Truthy한 값만 반환됨

    
    결론

      true || true : 첫번째 true를 만나면 전체 표현식의 결과가 이미 true 임이 확정되므로 "첫번째 true가 반환" (두번째 값은 평가되지 않음)
      false || false : 첫번째 값이 false이기 때문에 두번째 값도 평가해야 전체 결과르 알 수 있으므로 "두번째 false가 반환"

      true && true : 전체 표현식이 true가 되기 위해 두번째 값도 true여야 하므로 "두번째 true가 반환"
      false && false : 첫번째 false를 만나면 전체 표현식의 결과가 이미 false 임이 확정되므로 "첫번째 false가 반환"

      true && false : "두번째 false 반환"
      false && true : "첫번째 false 반환"

      true || false : "첫번쨰 true 반환"
      false || true : "두번째 true 반환"





  구조분해할당
    - 배열이나 객체에 저장된 여러 개의 값들을 분해해서 각각 다른 변수에 할당하는 문법

    1. 배열의 구조 분해 할당
      - 배열에 있는 원소들을 변수들의 순서대로 하나씩 분해해서 할당하는 문법
      
      let arr = [1, 2, 3]

      let [one, two, three, four] = arr;    // arr에 있는 배열의 요소들이 순서대로 각각 할당이 됨
      
      console.log(one, two, three, four)    // 1 2 3 undefined
      
      let [one, two, three, four = 4] = arr;    // 기본값 설정도 가능


    2. 객체의 구조 분해 할당

    let person = {
      name: "a",
      age: b,
      hobby: "c"
    };

    let name = person.name;
    let age = person.age;
    let hobby = person.hobby;

    를

    let { name, age, hobby, extra = "hello" } = person;

    let { name, age: myAge, hobby, extra = "hello" } = person;
      - myAge라는 변수에 age 프로퍼티의 값이 담긴다.


    3. 객체 구조 분해 할당을 이용해서 함수의 매개변수를 받는 방법

    const func = ( {name, age, hobby, extra} ) => {     // 객체를 넘겼을 때만 구조분해할당을 받을 수 있다.
    
    }





  Spread 연산자
    - 흩뿌리다, 펼치다
    - 객체나 배열에 저장된 여러 개의 값을 개별로 흩뿌려주는 역할
    - 배열의 값이나 객체의 프로퍼티를 풀어 해친다는 의미
    - ...

    let arr1 = [1, 2, 3];
    let arr2 = [4, 5, 6];

    arr2 = [4, arr1[0], arr1[1], arr1[2], 5, 6]

    대신에

    arr2 = [4, ...arr1, 5, 6]


    let obj1 = {
      a: 1,
      b: 2
    }

    let obj2 = {
      ...obj1,
      c: 3,
      d: 4
    }


    function funcA(p1, p2, p3) {          // 1, 2, 3

    }

    funcA(...arr1);




  Rest 매개변수
    - 나머지 매개변수
    - 매개변수를 배열에 한방에 다 담아서 저장할 수 있음
    - Rest 매개변수 뒤에 나오는 모든 인수들을 다 배열에 저장하는 문법이기 때문에,
    - Rest 매개변수 뒤에는 추가적인 매개변수가 올 수 없다.
    - Rest 매개변수는 마지막에 위치해야 한다.

    
    function funcB(...rest) {            // [1, 2, 3] spread 연산자와 다름
    
    }

    funcB(...arr1);

        function funcC(one, ...rest) {            // 첫번째 매개변수'만' 다르게 받고 싶은 경우. rest에는 [2, 3] 이렇게 저장됨
    
    }





    원시타입
      - Number, String, Boolean, Null, Undefined
      - 값 자체로써 변수에 저장되고 복사됨
      - 불변값 (실제로 메모리 공간에 저장된 원본 데이터 값은 변경되지 않음)

      code                        name              memory
      let p1 = 1;                  p1                 1
      let p2 = p1;                 p2                 1     // 변수의 값이 수정되더라도 메모리 공간에 저장된 원본 데이터의 값은 수정되지 않음
      p2 = 2;                      p2                 2     // 값을 새로운 메모리 공간에 추가적으로 저장한 뒤 1을 가리키던 것을 2를 가리키게 만듬

    객체타입
      - Object, Array, Function, RegexExp
      - 참조값을 통해 변수에 저장되고 복사됨
      - 가변값 (메모리 상에서 값이 수정됨)
      - 특정 값을 수정하면 메모리에 저장된 원본 데이터 자체가 수정된다.
      - 의도치않게 값이 수정되는 상황 주의

      code                        name              memory
      let o1 = {name: "a"};        o1,o2            참조값 0x0000C  (메모리 어딘가에 name:a 라는 객체를 따로 저장해둔 주소값[참조값]을 저장함) 
      let o2 = o1;                                                  (원시타입 값들과 다르게 배열이나 객체는 여러개의 값을 저장하고 개수가 동적으로 늘어나기 때문)
                                                    { name: "a" }
      o2.name = "b";                                참조값 0x0000D  (x) (새로운 값을 만드는 게 아니라 0x0000C 참조값 자체를 수정해버림) (원본 데이터를 수정함)
                                                    { nmae: "b"}    (x) (o2의 값만 바뀌는게 아니라 o1의 값도 바뀌어 버림) (메모리 상에서 값이 수정되어버림)

      의도치 않은 값 수정을 막으려면,
      let o2 = { ...o1 }
      이런식으로 내부 프로퍼티만 복사해오는 방식이 있음 (새로운 참조값을 가진 객체 생성)

      얕은 복사                                     깊은복사
      let o2 = o1;                                  let o2 = { ...o1 }
      객체의 참조값읇 복사함                        새로운 객체를 생성하면서 프로퍼티만 따로 복사함
      (원본 객체가 수정될 수 있어 위험함)           (원본 객체가 수정될 일이 없어 안전함)

      - 객체 값의 비교는 기본적으로 참조값을 기준으로 이루어짐
      - 얕은 복사는 같은 참조값을 가리키기 때문에 같은 객체를 가리킴    (o1 === o2) true
      - 깊은 복사는 새로운 참조값을 가리키기 때문에 다른 객체를 가리킴  (o1 === o2) false  , (JSON.stringify(o1) === JSON.stringify(o2)) true

      - JSON.stringify : 객체를 문자열로 형변환하는 내장함수



-->