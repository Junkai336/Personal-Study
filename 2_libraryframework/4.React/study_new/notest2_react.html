<!-- 
자바스크립트 심화

  Truthy & Falsy
    - 참이나 거짓을 의미하지 않는 값도 조건문 내에서 참이나 거짓으로 평가하는 특징

    - Falsy한 값
      - undefined
      - null
      - 0
      - -0
      - NaN
      - ""
      - 0n      // Big Integer

    - Truthy한 값
      - Falsy한 값 외에 전부
      - [], {}, () => {}; 다 truthy함

    - 활용

      function printName(person) {
        if(!person) return;                 // person === undefined || person === null

        console.log("person.name");
      }

      let person = null;
      printName(person)





  단락 평가(Short-circuit Evaluation)
    - 첫번째 피연산자의 값이 확정되었을 때 두번째 피연산자의 값에 접근조차 하지 않는 것
    - 조건문을 이용하지 않고도 특정 상황에서 어떠한 함수를 호출하지 않도록 방지하거나 어떠한 값들을 굳이 계산하지 않도록 제한하는 등 할 수 있음
    - 논리 연산식에서 첫번째 피연산자의 값만으로도 연산의 결과를 확정할 수 있다면 두 번째 피연산자에는 접근조차 하지 않는 실행 방식
    - true, false 뿐만 아니라 truthly, falshy한 값도 적용됨

    function returnFalse() {
      console.log("False 함수");
      return false;
    }

    function returnTrue() {
      console.log("True 함수");
      return true;
    }

    console.log(returnFalse() && returnTrue());     // False 함수 , false 만 출력된다.

    console.log(returnTrue() && returnFalse());     // True 함수, False 함수 둘 다 호출되고 false 가 출력된다.

    console.log(returnTrue() || returnFalse());     // True 함수 , true 만 출력된다.

    예시

    let name = null
    let defaultName = "Anoymous";

    let displayName = name || defaultName;  // name이 falshy한 값이라 defaultName이 됨. 반대로 name이 있으면 name이 됨

    예시2

    function printName(person) {
      if(!person) {
        console.log("person에 값이 없음");
        return;
      }

      console.log(person.name);
    }

    대신에

    function printName(person) {
      console.log(person && person.name);
    }

    function printName(person) {
      const name = person && person.name;
      console.log (name || "person의 값이 없습니다.");
    }

    - Truthy한 값 || Truthy한 값 일 경우에 첫 번째 Truthy한 값만 반환됨
    - Truthy한 값 && Truthy한 값 일 경우에 두 번째 Truthy한 값만 반환됨

    
    결론

      true || true : 첫번째 true를 만나면 전체 표현식의 결과가 이미 true 임이 확정되므로 "첫번째 true가 반환" (두번째 값은 평가되지 않음)
      false || false : 첫번째 값이 false이기 때문에 두번째 값도 평가해야 전체 결과르 알 수 있으므로 "두번째 false가 반환"

      true && true : 전체 표현식이 true가 되기 위해 두번째 값도 true여야 하므로 "두번째 true가 반환"
      false && false : 첫번째 false를 만나면 전체 표현식의 결과가 이미 false 임이 확정되므로 "첫번째 false가 반환"

      true && false : "두번째 false 반환"
      false && true : "첫번째 false 반환"

      true || false : "첫번쨰 true 반환"
      false || true : "두번째 true 반환"





  구조분해할당
    - 배열이나 객체에 저장된 여러 개의 값들을 분해해서 각각 다른 변수에 할당하는 문법

    1. 배열의 구조 분해 할당
      - 배열에 있는 원소들을 변수들의 순서대로 하나씩 분해해서 할당하는 문법
      
      let arr = [1, 2, 3]

      let [one, two, three, four] = arr;    // arr에 있는 배열의 요소들이 순서대로 각각 할당이 됨
      
      console.log(one, two, three, four)    // 1 2 3 undefined
      
      let [one, two, three, four = 4] = arr;    // 기본값 설정도 가능


    2. 객체의 구조 분해 할당

    let person = {
      name: "a",
      age: b,
      hobby: "c"
    };

    let name = person.name;
    let age = person.age;
    let hobby = person.hobby;

    를

    let { name, age, hobby, extra = "hello" } = person;

    let { name, age: myAge, hobby, extra = "hello" } = person;
      - myAge라는 변수에 age 프로퍼티의 값이 담긴다.


    3. 객체 구조 분해 할당을 이용해서 함수의 매개변수를 받는 방법

    const func = ( {name, age, hobby, extra} ) => {     // 객체를 넘겼을 때만 구조분해할당을 받을 수 있다.
    
    }





  Spread 연산자
    - 흩뿌리다, 펼치다
    - 객체나 배열에 저장된 여러 개의 값을 개별로 흩뿌려주는 역할
    - 배열의 값이나 객체의 프로퍼티를 풀어 해친다는 의미
    - ...

    let arr1 = [1, 2, 3];
    let arr2 = [4, 5, 6];

    arr2 = [4, arr1[0], arr1[1], arr1[2], 5, 6]

    대신에

    arr2 = [4, ...arr1, 5, 6]


    let obj1 = {
      a: 1,
      b: 2
    }

    let obj2 = {
      ...obj1,
      c: 3,
      d: 4
    }


    function funcA(p1, p2, p3) {          // 1, 2, 3

    }

    funcA(...arr1);




  Rest 매개변수
    - 나머지 매개변수
    - 매개변수를 배열에 한방에 다 담아서 저장할 수 있음
    - Rest 매개변수 뒤에 나오는 모든 인수들을 다 배열에 저장하는 문법이기 때문에,
    - Rest 매개변수 뒤에는 추가적인 매개변수가 올 수 없다.
    - Rest 매개변수는 마지막에 위치해야 한다.

    
    function funcB(...rest) {            // [1, 2, 3] spread 연산자와 다름
    
    }

    funcB(...arr1);

        function funcC(one, ...rest) {            // 첫번째 매개변수'만' 다르게 받고 싶은 경우. rest에는 [2, 3] 이렇게 저장됨
    
    }





    원시타입
      - Number, String, Boolean, Null, Undefined
      - 값 자체로써 변수에 저장되고 복사됨
      - 불변값 (실제로 메모리 공간에 저장된 원본 데이터 값은 변경되지 않음)

      code                        name              memory
      let p1 = 1;                  p1                 1
      let p2 = p1;                 p2                 1     // 변수의 값이 수정되더라도 메모리 공간에 저장된 원본 데이터의 값은 수정되지 않음
      p2 = 2;                      p2                 2     // 값을 새로운 메모리 공간에 추가적으로 저장한 뒤 1을 가리키던 것을 2를 가리키게 만듬

    객체타입
      - Object, Array, Function, RegexExp
      - 참조값을 통해 변수에 저장되고 복사됨
      - 가변값 (메모리 상에서 값이 수정됨)
      - 특정 값을 수정하면 메모리에 저장된 원본 데이터 자체가 수정된다.
      - 의도치않게 값이 수정되는 상황 주의

      code                        name              memory
      let o1 = {name: "a"};        o1,o2            참조값 0x0000C  (메모리 어딘가에 name:a 라는 객체를 따로 저장해둔 주소값[참조값]을 저장함) 
      let o2 = o1;                                                  (원시타입 값들과 다르게 배열이나 객체는 여러개의 값을 저장하고 개수가 동적으로 늘어나기 때문)
                                                    { name: "a" }
      o2.name = "b";                                참조값 0x0000D  (x) (새로운 값을 만드는 게 아니라 0x0000C 참조값 자체를 수정해버림) (원본 데이터를 수정함)
                                                    { nmae: "b"}    (x) (o2의 값만 바뀌는게 아니라 o1의 값도 바뀌어 버림) (메모리 상에서 값이 수정되어버림)

      의도치 않은 값 수정을 막으려면,
      let o2 = { ...o1 }
      이런식으로 내부 프로퍼티만 복사해오는 방식이 있음 (새로운 참조값을 가진 객체 생성)

      얕은 복사                                     깊은복사
      let o2 = o1;                                  let o2 = { ...o1 }
      객체의 참조값읇 복사함                        새로운 객체를 생성하면서 프로퍼티만 따로 복사함
      (원본 객체가 수정될 수 있어 위험함)           (원본 객체가 수정될 일이 없어 안전함)

      - 객체 값의 비교는 기본적으로 참조값을 기준으로 이루어짐
      - 얕은 복사는 같은 참조값을 가리키기 때문에 같은 객체를 가리킴    (o1 === o2) true
      - 깊은 복사는 새로운 참조값을 가리키기 때문에 다른 객체를 가리킴  (o1 === o2) false  , (JSON.stringify(o1) === JSON.stringify(o2)) true

      - JSON.stringify : 객체를 문자열로 형변환하는 내장함수




  순회(Iteration)
    - 배열, 객체에 저장된 여러 개의 값에 순서대로 하나씩 접근하는 것

  배열

    for of 반복문
      - 배열을 순회하기 위해서만 존재하는 반복문
      - 인덱스를 저장하지 않고 배열 안에 있는 값들을 순회한다.

      let arr = [1, 2, 3]

      for (let item of arr) {
        console.log(item);
      }

  객체

    Object.keys
      - 객체에서 key 값들만 뽑아서 새로운 배열로 반환

      let person = { name: "a", age: 1, hobby: "b"};
      
      let keys = Object.keys(person);                   // ['name', 'age', 'hobby']

      for (let key of keys) { 
        const value = person[key];

        console.log(key, value);                        // name a age 1 hobby b
      }


    Object.values
      - 객체에서 value 값들만 뽑아서 새로운 배열로 반환

      let values = Object.values(person);               // a, 1, b

      for (let value of values) {
        console.log(value);
      }


    for in 반복문

      for (let key in person) {
        const value = person[key];

        console.log(key, value);
      }





배열 메소드

  요소 조작 메소드

    1. push
      - 배열의 맨 뒤에 새로운 요소 추가
      - 배열의 총 길이를 반환함(length)

      let arr1 = [1, 2, 3];
      arr1.push(4, 5, 6);                     // [1,2,3,4,5,6]

      let newLen = arr1.push(7);              // 7


    2. pop
      - 배열의 맨 뒤에 요소 제거
      - 제거된 배열 아이템을 반환함

      let arr2  = [1, 2, 3];
      const poppedItem = arr2.pop();          // [1, 2] , 3


    3. shift
      - 배열의 맨 앞에 있는 요소를 제거
      - 제거된 배열 아이템을 반환함
      - pop보다 느리게 동작

      let arr3 = [1, 2, 3];
      const shiftedItem = arr3.shift();     // [2, 3] , 1


    4. unshift
      - 배열의 맨 앞에 새로운 요소를 추가
      - 배열의 총 길이를 반환함(length)
      - push보다 느리게 동작

      let arr4 = [1, 2, 3];
      let newLen = arr4.unshift(0);       // [0, 1, 2, 3] , 4


    5. slice
      - 배열의 특정 범위를 잘라내서 새로운 배열로 반환
      - 시작 인덱스부터 끝 인덱스 '전' 까지 잘라냄  (+1을 해서 넣어야 함)
      - 원본 배열을 잘라내더라도, 원본 배열 값이 달라지진 않음
      - 두번째 인수를 생략하면, 시작 인덱스부터 끝까지 잘라냄

      let arr5 = [1, 2, 3, 4, 5];
      let sliced = arr5.slice(2, 5);      // [3, 4, 5]
      let sliced2 = arr5.slice(-3);       // [1, 2]


    6. concat
      - 2개의 서로 다른 배열을 이어 붙여서 새로운 배열로 반환

      let arr6 = [1, 2];
      let arr7 = [3, 4];

      arr6.concat(arr7);                  // [1, 2, 3, 4]



  요소 순회 및 탐색 메소드

    1. forEach
      - 모든 요소를 순회하면서 각각 요소에 특정 동작을 수행시키는 메소드
      - 매 반복마다 콜백 함수를 호출하고 매개 변수로 현재 요소의 값, 반복 카운트, 전체 배열의 값 전달

      let arr1 = [1, 2, 3];

      arr1.forEach(function (item, index, arr) {
        console.log(item, index, arr);
                    1      0    [1,2,3]
      });

      let doubledArr = [];

      arr1.forEach((item) => {
        doubledArr.push(item * 2);                // [2, 4, 6]
      });


    2. includes
      - 배열에 특정 요소가 있는지 확인하는 메소드

      let arr2 = [1, 2, 10];

      let isInclude = arr2.includes(10);                                    // true


    3. indexOf
      - 특정 요소의 인덱스(위치)를 찾아서 반환하는 메소드
      - 값이 동일한 요소가 여러개 있다면 맨 처음 찾아낸 인덱스 반환
      - 존재하지 않는 값은 -1 반환
      - 배열에서 특정 객체값이 존재하는지는 찾을 수 없음

      let arr3 = [1, 2, 3];
      let index = arr3.indexOf(2);                                          // 2라는 값이 어디있는지 찾아서 인덱스 반환 = 1번 인덱스

      let objectArr = [
        { name: "a"},
        { name: "b"}
      ]

      console.log(objectArr.indexOf({name : "a"}));                         // 결과 : -1 (무조건 얕은비교, 동등비교, === 를 이용해 비교하기 때문에 객체값을 찾을 수 없음)


    4. findIndex
      - 특정 요소의 인덱스(위치)를 찾아서 반환하는 메소드
      - 모든 요소를 순회하면서, 콜백함수를 만족하는 요소를 배열에서 찾아서 그 인덱스를 반환 (콜백함수가 참을 반환한다는 의미)
      - 콜백함수를 이용해서 특정 조건을 만족하는 요소의 위치를 배열에서 찾아내는 것이 가능
      - 조건에 만족하는 요소가 배열에서 존재하지 않는다면 -1 반환

      let arr4 = [1, 2, 3];

      const findedIndex = arr4.findIndex((item) => {
        if(item === 2) return true;                                         // 1 [2의 위치 반환]
      });

      const findedIndex2 = arr4.findIndex((item) => item % 2 !== 0);        // 0 [1의 위치 반환]

      console.log(
        objectArr.findIndex((item) => {
          item.name === "a"                                                 // 결과 : 0 (직접 프로퍼티의 값을 기준으로 비교를 시켜줄 수 있기 때문에 조건식을 잘 세우면 객체값을 찾을 수 있음)
        });
      );


    5. find
      - 모든 요소를 순회하면서 콜백 함수를 만족하는 요소를 찾고, 요소를 그대로 반환

      let arr = 5 [
        {name: a},
        {name: b}
      ];

      arr5.find((item) => item.name === "a");                             // 결과 : {name: a} , 객체 그 자체가 반환됨




  배열 변형 메소드

    1. filter
      - 기존 배열에서 조건을 만족하는 요소들만 필터링하여 새로운 배열로 반환
      - '조건'을 만족하는 값들만 새로운 배열로 반환

      let arr1 = [
        { name : "a", hobby: "테니스"},
        { name : "b", hobby: "테니스"},
        { name : "c", hobby: "독서"}
      ]

      arr1.filter((item) => {
        if (item.hobby === "테니스") return true;
      });

      const tennisPeople = arr1.filter( (item) => item.hobby === "테니스"  );

      결과
        [
          { name : "a", hobby: "테니스"},
          { name : "b", hobby: "테니스"}
        ]


    2. map
      - 배열의 모든 요소를 순회하면서, 각각 콜백함수를 실행하고 그 결과값들을 모아서 새로운 배열로 반환

      let arr2 = [1, 2, 3];

      const mapResult1 = arr2.map((item, index, array) => {
        console.log(index, item);                     // 0 1 , 1 2 , 2 3

        return item * 2;                              // 반환값을 설정할 수 있음. map 메소드가 콜백함수가 반환한 값들을 다 모아서 새로운 배열로 반환시켜줌 
      });

      console.log(mapResult1);                        // [2, 4, 6]


      let names = arr1.map(() => item.name);          // [a, b]


    3. sort
      - 배열을 사전순으로 정렬하는 메소드

      let arr3 = ["b", "a", "c"];

      arr3.sort();                                    // [a, b, c]

      let arr4 = [10, 3, 5]

      arr4.sort();                                    // [10, 3, 5] <- 사전순으로 정렬하기 때문에 숫자의 대소비교 X

      => sort 메소드를 설정하면서 비교 기준을 설정하는 콜백 함수 필요

      - 오름차순 정렬
                두개의 배열값
        arr4.sort((a, b) => {
          if(a > b) {
                                                      // 오름차순 : b가 a 앞에 와라
                                                      // sort 함수에서 양수를 반환하면 둘 중에 더 작은 값이 앞에 온다. = b가 a 앞으로 오게 된다.
            return 1;                                 // b, a 배치
          } else if (a < b) {
                                                      // 내림차순 : a가 b 앞에 와라
            return -1                                 // a, b 배치
          } else {
                                                      // 두 값이 같으면 자리를 바꾸지 마라
            return 0                                  // a, b 자리를 그대로 유지
          }
        })

      - 내림차순 정렬

        arr4.sort((a, b) => {
          if (a > b) {
            return -1;
          } else if (a < b) {
            return 1;
          } else {
            return 0;
          }
        });

        // 양수 반환 : Sort 내부에서 B가 A 앞으로 오도록 배치해라.
        // 음수 반환 : Sort 내부에서 A가 B 앞으로 오도록 배치해라.


    4. toSorted
      - Sort는 원본배열 자체를 변형시킴
      - toSorted는 정렬된 새로운 배열을 반환하는 메소드

      let arr5 = ["c", "a", "b"];
      const sorted = arr5.toSorted();

      console.log(arr5);                              // [c, a, b]
      console.log(sorted)                             // [a, b, c]


    5. join
      - 배열의 모든 요소를 하나의 문자열로 합쳐서 반환하는 메소드
      - , : separator 구분자. 인자로 구분자를 바꿀 수 있음

      let arr6 = ["hi", "im", "a"];

      const joined = arr6.join();                   // "hi,im,a"
      const joined = arr6.join(" ");                // "hi im a"




  DATE 객체

    1. Date 객체 생성법

      let date1 = new Date();                                 // 생성자, 인수가 없을 시 현재 지금 시간을 저장하는 Date 객체 생성

      let date2 = new Date("1997-01-07-10:10:10");           // 특정 날짜 기준으로 출력

      let date3 = new Date(1997, 1, 7, 23, 59, 59);


    2. 타임 스탬프
                      (협정 세계시 : UTC)
      - 특정 시간이 "1970.01.01 00시 00분 00초"로부터 몇 ms가 지났는지를 의미하는 숫자값
      - 복잡한 시간 정보를 수자로 관리할 수 있도록 함
      - UTC : 세계의 모든 나라가 표준으로 사용하는 시간이 시작되는 지점

      let timestamp1 = data1.getTime();                       // 17054111155293.. 타임스탬프, UTC 시간으로부터 지금 이만큼 ms가 지난 시간이 저장되어 있다.

      let data4 = new Date(timestamp1);                       // Tue Jan 16 2024 22:20:41 ...


    3. 


-->