<!-- 
자바스크립트 심화

  Truthy & Falsy
    - 참이나 거짓을 의미하지 않는 값도 조건문 내에서 참이나 거짓으로 평가하는 특징

    - Falsy한 값
      - undefined
      - null
      - 0
      - -0
      - NaN
      - ""
      - 0n      // Big Integer

    - Truthy한 값
      - Falsy한 값 외에 전부
      - [], {}, () => {}; 다 truthy함

    - 활용

      function printName(person) {
        if(!person) return;                 // person === undefined || person === null

        console.log("person.name");
      }

      let person = null;
      printName(person)





  단락 평가(Short-circuit Evaluation)
    - 첫번째 피연산자의 값이 확정되었을 때 두번째 피연산자의 값에 접근조차 하지 않는 것
    - 조건문을 이용하지 않고도 특정 상황에서 어떠한 함수를 호출하지 않도록 방지하거나 어떠한 값들을 굳이 계산하지 않도록 제한하는 등 할 수 있음
    - 논리 연산식에서 첫번째 피연산자의 값만으로도 연산의 결과를 확정할 수 있다면 두 번째 피연산자에는 접근조차 하지 않는 실행 방식
    - true, false 뿐만 아니라 truthly, falshy한 값도 적용됨

    function returnFalse() {
      console.log("False 함수");
      return false;
    }

    function returnTrue() {
      console.log("True 함수");
      return true;
    }

    console.log(returnFalse() && returnTrue());     // False 함수 , false 만 출력된다.

    console.log(returnTrue() && returnFalse());     // True 함수, False 함수 둘 다 호출되고 false 가 출력된다.

    console.log(returnTrue() || returnFalse());     // True 함수 , true 만 출력된다.

    예시

    let name = null
    let defaultName = "Anoymous";

    let displayName = name || defaultName;  // name이 falshy한 값이라 defaultName이 됨. 반대로 name이 있으면 name이 됨

    예시2

    function printName(person) {
      if(!person) {
        console.log("person에 값이 없음");
        return;
      }

      console.log(person.name);
    }

    대신에

    function printName(person) {
      console.log(person && person.name);
    }

    function printName(person) {
      const name = person && person.name;
      console.log (name || "person의 값이 없습니다.");
    }

    - Truthy한 값 || Truthy한 값 일 경우에 첫 번째 Truthy한 값만 반환됨
    - Truthy한 값 && Truthy한 값 일 경우에 두 번째 Truthy한 값만 반환됨

    
    결론

      true || true : 첫번째 true를 만나면 전체 표현식의 결과가 이미 true 임이 확정되므로 "첫번째 true가 반환" (두번째 값은 평가되지 않음)
      false || false : 첫번째 값이 false이기 때문에 두번째 값도 평가해야 전체 결과르 알 수 있으므로 "두번째 false가 반환"

      true && true : 전체 표현식이 true가 되기 위해 두번째 값도 true여야 하므로 "두번째 true가 반환"
      false && false : 첫번째 false를 만나면 전체 표현식의 결과가 이미 false 임이 확정되므로 "첫번째 false가 반환"

      true && false : "두번째 false 반환"
      false && true : "첫번째 false 반환"

      true || false : "첫번쨰 true 반환"
      false || true : "두번째 true 반환"





  구조분해할당
    - 배열이나 객체에 저장된 여러 개의 값들을 분해해서 각각 다른 변수에 할당하는 문법

    1. 배열의 구조 분해 할당
      - 배열에 있는 원소들을 변수들의 순서대로 하나씩 분해해서 할당하는 문법
      
      let arr = [1, 2, 3]

      let [one, two, three, four] = arr;    // arr에 있는 배열의 요소들이 순서대로 각각 할당이 됨
      
      console.log(one, two, three, four)    // 1 2 3 undefined
      
      let [one, two, three, four = 4] = arr;    // 기본값 설정도 가능


    2. 객체의 구조 분해 할당

    let person = {
      name: "a",
      age: b,
      hobby: "c"
    };

    let name = person.name;
    let age = person.age;
    let hobby = person.hobby;

    를

    let { name, age, hobby, extra = "hello" } = person;

    let { name, age: myAge, hobby, extra = "hello" } = person;
      - myAge라는 변수에 age 프로퍼티의 값이 담긴다.


    3. 객체 구조 분해 할당을 이용해서 함수의 매개변수를 받는 방법

    const func = ( {name, age, hobby, extra} ) => {     // 객체를 넘겼을 때만 구조분해할당을 받을 수 있다.
    
    }





  Spread 연산자
    - 흩뿌리다, 펼치다
    - 객체나 배열에 저장된 여러 개의 값을 개별로 흩뿌려주는 역할
    - 배열의 값이나 객체의 프로퍼티를 풀어 해친다는 의미
    - ...

    let arr1 = [1, 2, 3];
    let arr2 = [4, 5, 6];

    arr2 = [4, arr1[0], arr1[1], arr1[2], 5, 6]

    대신에

    arr2 = [4, ...arr1, 5, 6]


    let obj1 = {
      a: 1,
      b: 2
    }

    let obj2 = {
      ...obj1,
      c: 3,
      d: 4
    }


    function funcA(p1, p2, p3) {          // 1, 2, 3

    }

    funcA(...arr1);




  Rest 매개변수
    - 나머지 매개변수
    - 매개변수를 배열에 한방에 다 담아서 저장할 수 있음
    - Rest 매개변수 뒤에 나오는 모든 인수들을 다 배열에 저장하는 문법이기 때문에,
    - Rest 매개변수 뒤에는 추가적인 매개변수가 올 수 없다.
    - Rest 매개변수는 마지막에 위치해야 한다.

    
    function funcB(...rest) {            // [1, 2, 3] spread 연산자와 다름
    
    }

    funcB(...arr1);

        function funcC(one, ...rest) {            // 첫번째 매개변수'만' 다르게 받고 싶은 경우. rest에는 [2, 3] 이렇게 저장됨
    
    }
-->